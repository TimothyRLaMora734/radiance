loadGlsl({
    "resources/effects/green.glsl": "#property description Zero out the everything but the green channel (green is not a creative color)\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    fragColor.r *= 1. - iIntensity;\n    fragColor.b *= 1. - iIntensity;\n}\n", 
    "resources/effects/hpass.glsl": "#property description Pass-thru when there are \"highs\" in the music\n\nvoid main(void) {\n    float k = iAudioHi * 3.;\n    fragColor = texture(iInput, uv) * mix(1., min(k, 1.), iIntensity);\n}\n", 
    "resources/effects/delay.glsl": "#property description Introduce a delay (and make things blurry)\n\n#define SZ 6.    // Delay of SZ*SZ frames (36)\nvoid main(void) {\n    vec4 original = texture(iInput, uv);\n    vec2 uvNew = mix(uv / SZ, uv, smoothstep(0.8, 0.9, iIntensity));\n    vec4 delayed = texture(iChannel[1], uvNew);\n    fragColor = mix(original, delayed, smoothstep(0., 0.2, iIntensity));\n}\n\n#buffershader\n\n#define SZ 6.\nvoid main(void) {\n    vec2 uvNext = uv + vec2(1., 0.) / SZ;\n    float i;\n    uvNext.x = modf(uvNext.x, i);\n    uvNext.y += i / SZ;\n    if (uvNext.y > 1.0) {\n        fragColor = texture(iInput, 1.0 - (1.0 - uv) * SZ);\n    } else {\n        fragColor = texture(iChannel[1], uvNext);\n    }\n}\n", 
    "resources/effects/sscan.glsl": "#property description White slit for testing\n\nvoid main(void) {\n    float xc = iIntensity;\n    vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n    color *= 1. - step(0.5 * onePixel, abs(xc - uv.x));\n    fragColor = texture(iInput, uv);\n    fragColor = composite(fragColor, color);\n}\n", 
    "resources/effects/invstrobe.glsl": "#property description Image disappears on the beat\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c;\n\n    float freq;\n    if(iIntensity < 0.05) freq = 0.;\n    else if(iIntensity < 0.45) freq = 2.;\n    else freq = 1.;\n\n    if(freq > 0.) {\n        fragColor *= 1. - (sawtooth(iTime / freq, 0.2) * smoothstep(0., 0.2, iIntensity) * min(3. * iAudioLevel, 1.));\n    }\n}\n", 
    "resources/effects/rainbow.glsl": "#property description Cycle the color (in HSV) over time\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n\n    float deviation;\n    deviation = mod(iIntensityIntegral * 0.5, 1.);\n\n    vec4 hsv = demultiply(fragColor);\n    hsv.rgb = rgb2hsv(hsv.rgb);\n    hsv.r = mod(hsv.r + 1. + deviation, 1.);\n    hsv.rgb = hsv2rgb(hsv.rgb);\n    hsv = premultiply(hsv);\n\n    fragColor.rgb = mix(fragColor.rgb, hsv.rgb, smoothstep(0., 0.2, iIntensity));\n}\n", 
    "resources/effects/crossfader.glsl": "#property description Mix between the two inputs\n#property inputCount 2\nvoid main() {\n    vec4 l = texture(iInputs[0], uv);\n    vec4 r = texture(iInputs[1], uv);\n    fragColor = mix(l, r, iIntensity);\n}\n", 
    "resources/effects/swipe.glsl": "#property description Only update a vertical slice that slides across\n\nvoid main(void) {\n    vec4 prev = texture(iChannel[0], uv);\n    vec4 next = texture(iInput, uv);\n    float factor = pow(iIntensity, 2.0);\n\n    float t = mod(iTime / 4.0 - uv.x, 1.0);\n    float x = 0.0;\n    if (t < 0.5) x = pow(0.5 - t, 3.0);\n\n    factor = min(factor, 1.0 - x);\n    factor = clamp(factor, 0.0, 1.0);\n\n    fragColor = mix(next, prev, factor);\n}\n", 
    "resources/effects/wstrobe.glsl": "#property description White strobe to the beat\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c;\n\n    float freq;\n    if(iIntensity < 0.05) freq = 0.;\n    else if(iIntensity < 0.25) freq = 4.;\n    else if(iIntensity < 0.45) freq = 2.;\n    else if(iIntensity < 0.65) freq = 1.;\n    else if(iIntensity < 0.85) freq = 0.5;\n    else freq = 0.25;\n\n    if(freq > 0.) {\n        vec3 hsv = rgb2hsv(demultiply(fragColor).rgb);\n        hsv.y = hsv.y * (1. - sawtooth(iTime / freq, 0.1));\n        fragColor.rgb = hsv2rgb(hsv);\n        fragColor = premultiply(fragColor);\n    }\n}\n", 
    "resources/effects/fireball.glsl": "#property description Fileball in the center\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    vec3 noise_input = vec3(length(normCoord) * 3. - iTime, abs(atan(normCoord.y, normCoord.x)), iTime * 0.3);\n    vec2 shift = (vec2(noise(noise_input), noise(noise_input + 100.)) - 0.5);\n    shift += (vec2(noise(2. * noise_input), noise(2. * noise_input + 100.)) - 0.5) * 0.5;\n    shift += (vec2(noise(4. * noise_input), noise(4. * noise_input + 100.)) - 0.5) * 0.25;\n    shift = (iIntensity * 0.7 + 0.3) * shift;\n\n    normCoord = normCoord + shift;\n    vec4 color = vec4(1., length(normCoord) * 2., 0., 1.0);\n    color.g = clamp(color.g, 0.0, 1.0);\n    color *= smoothstep(0.4, 0.5, (1. - length(normCoord)));\n    color *= smoothstep(0., 0.2, iIntensity);\n\n    fragColor = composite(fragColor, color);\n}\n", 
    "resources/effects/resat.glsl": "#property description Recolor output with perlin noise rainbow\n\nvoid main(void) {\n    float factor = pow(iIntensity, 0.6);\n    vec3 noise_input = vec3(uv, iTime / 8.);\n    float n = noise(noise_input) - 0.1;\n    n += (noise(2. * noise_input) - 0.5) * 0.5;\n    n += (noise(4. * noise_input) - 0.5) * 0.25;\n    //n = mod(n + 0.5, 1.0);\n    //n = mod(n + hsl.r, 1.0);\n\n    vec4 samp = texture(iInput, uv);\n    vec3 hsl = rgb2hsv(samp.rgb);\n    hsl.g = 1.0 - (1.0 - hsl.g) * (1.0 - factor);\n    //hsl.r = mix(hsl.r, n, iIntensity);\n    hsl.r = mod(hsl.r + n * iIntensity, 1.0);\n    fragColor.rgb = hsv2rgb(hsl);\n    fragColor.a = samp.a;\n}\n", 
    "resources/effects/crt.glsl": "#property description CRT-style effect\n\nvoid main(void) {\n    vec2 separate = iIntensity * vec2(0.005, 0.0);\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2 redOffset = normCoord - separate;\n    vec2 greenOffset = normCoord;\n    vec2 blueOffset = normCoord + separate;\n\n    vec4 redImage = texture(iInput, redOffset / aspectCorrection + 0.5);\n    vec4 greenImage = texture(iInput, greenOffset / aspectCorrection + 0.5);\n    vec4 blueImage = texture(iInput, blueOffset / aspectCorrection + 0.5);\n\n    vec3 rgb = vec3(redImage.r, greenImage.g, blueImage.b);\n    rgb *= mix(1.0, 1.0 - pow(abs(sin(greenOffset.y * 160.0)), 16.), iIntensity / 3.0);\n    rgb.r *= mix(1.0, 1.0 - pow(abs(sin(redOffset.x * 200.0)), 6.), iIntensity);\n    rgb.g *= mix(1.0, 1.0 - pow(abs(sin(greenOffset.x * 200.0)), 6.), iIntensity);\n    rgb.b *= mix(1.0, 1.0 - pow(abs(sin(blueOffset.x * 200.0)), 6.), iIntensity);\n    float a_out = max(max(greenImage.a, rgb.r), max(rgb.g, rgb.b));\n    fragColor = vec4(rgb, a_out);\n}\n", 
    "resources/effects/edge.glsl": "#property description From https://www.shadertoy.com/view/XssGD7\n\nvec4 get_texture(vec2 offset) {\n    //return demultiply(texture(iInput, uv + offset));\n    return texture(iInput, uv + offset);\n}\n\nvoid main()\n{\n\t// Sobel operator\n\tfloat off = onePixel;\n\tvec3 o = vec3(-off, 0.0, off);\n\tvec4 gx = vec4(0.0);\n\tvec4 gy = vec4(0.0);\n\tvec4 t;\n\tgx += get_texture(o.xz);\n\tgy += gx;\n\tgx += 2.0*get_texture(o.xy);\n\tt = get_texture(o.xx);\n\tgx += t;\n\tgy -= t;\n\tgy += 2.0*get_texture(o.yz);\n\tgy -= 2.0*get_texture(o.yx);\n\tt = get_texture(o.zz);\n\tgx -= t;\n\tgy += t;\n\tgx -= 2.0*get_texture(o.zy);\n\tt = get_texture(o.zx);\n\tgx -= t;\n\tgy -= t;\n\tvec4 grad = sqrt(gx * gx + gy * gy);\n    grad.a = max(max(grad.r, grad.g), max(grad.b, grad.a));\n\n    vec4 original = texture(iInput, uv);\n    grad *= smoothstep(0., 0.5, iIntensity);\n    original *= 1. - smoothstep(0.5, 1., iIntensity);\n\n    fragColor = composite(original, grad);\n}\n", 
    "resources/effects/melt.glsl": "#property description The walls are melting\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c = texture(iChannel[1], uv);\n    c *= smoothstep(0., 0.2, iIntensity);\n    fragColor = composite(fragColor, c);\n}\n\n#buffershader\n\nvoid main(void) {\n    vec4 c1 = texture(iInput, uv);\n\n    vec2 perturb = sin(uv.yx * 10. + sin(vec2(iIntensityIntegral * 1., iIntensityIntegral * 1.5))); // Perturb a little to make the melting more wavy\n    perturb *= 1. - smoothstep(0.9, 1., uv.y); // Don't perturb near the top to avoid going off-texture\n\n    vec4 c2 = texture(iChannel[1], uv + vec2(0., 0.01 * iIntensity) + 0.005 * iIntensity * perturb);\n\n    fragColor = max(c1, c2); // Blend between the current frame and a slightly shifted down version of it using the max function\n    fragColor = max(fragColor - 0.002 - 0.02 * (1. - iIntensity), vec4(0)); // Fade it out slightly\n\n    fragColor *= smoothstep(0., 0.1, iIntensity); // Clear back buffer when intensity is low\n}\n", 
    "resources/effects/brighten.glsl": "#property description Make the image more white\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    fragColor = mix(fragColor, vec4(fragColor.a), iIntensity);\n}\n", 
    "resources/effects/dunkirk.glsl": "#property description Apply a Dunkirk-esque (dark blue) palette\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec3 hsv = rgb2hsv(fragColor.rgb);\n    float h = hsv.x;\n    h = mod(h - 1. / 12., 1.0) - 6. / 12.;\n    h *= (1. - iIntensity * 0.7);\n    h = mod(h + 7. / 12., 1.0);\n    hsv.x = h;\n    hsv.y = mix(hsv.y, 0., iIntensity * 0.4);\n    hsv.z = mix(hsv.z, 0., iIntensity * 0.3);\n    fragColor.rgb = hsv2rgb(hsv);\n}\n", 
    "resources/effects/cga1.glsl": "#property description CGA mode 1: black, cyan, magenta, white\n\nvoid main(void) {\n    // This is pretty gross\n    vec4 oc = texture(iInput, uv);\n    vec3 c = oc.rgb;\n    c = min(c / max(oc.a, 0.001), 1.);\n    float bDist = -length(c - vec3(0., 0., 0.));\n    float wDist = -length(c - vec3(1., 1., 1.));\n    float cDist = -length(c - vec3(0., 1., 1.));\n    float mDist = -length(c - vec3(1., 0., 1.));\n\n    if (wDist > bDist && wDist > cDist && wDist > mDist) {\n        c = vec3(1., 1., 1.);\n    } else if (cDist > bDist && cDist > wDist && cDist > mDist) {\n        c = vec3(0., 1., 1.);\n    } else if (mDist > bDist && mDist > wDist && mDist > cDist) {\n        c = vec3(1., 0., 1.);\n    } else {\n        c = vec3(0., 0., 0.);\n    }\n\n    fragColor.rgb = mix(oc.rgb, c, iIntensity);\n    fragColor.a = oc.a;\n}\n", 
    "resources/effects/bespeckle.glsl": "#property description Brownian-ish speckle effect\n\nvoid main(void) {\n    vec4 old = texture(iChannel[0], uv);\n    vec4 new = texture(iInput, uv);\n\n    float r = rand(vec3(uv, iTime));\n    float k = pow(mix(1.0, r, iIntensity), 16.0);\n    fragColor = mix(old, new, k);\n\n    // I don't think this is required, but just be safe\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, fragColor.a);\n}\n", 
    "resources/effects/strange.glsl": "#property description Strange tentacles\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    // Build a vector to use to sample perlin noise from\n    // .xy ~ coordinate, .z ~ time + audio, .w ~ fixed integer per call to noise()\n    vec4 noise_input = vec4(0.);\n    noise_input.xy = 5. * normCoord * smoothstep(0., 0.4, iIntensity);\n    noise_input.z = iIntensityIntegral * 0.4 + iAudioLevel * mix(0.2, 0.7, iIntensity);\n\n    float n;\n    // Sample perlin noise with many octaves\n    n = noise(noise_input) - 0.1;\n    n += (noise(2. * noise_input) - 0.5) * 0.5;\n    n += (noise(4. * noise_input) - 0.5) * 0.25;\n    n += (noise(8. * noise_input) - 0.5) * 0.125;\n    n += (noise(16. * noise_input) - 0.5) * 0.0625;\n    // Take the noise and create \"ridges\", call it `a`\n    n -= 0.5;\n    n *= mix(14.0, 4.0, iAudioLevel);\n    n = clamp(abs(n), 0., 1.);\n    n = 1.0 - pow(n, mix(1.0, 4.0, iAudioLevel));\n    float a = n;\n\n    // Sample perlin noise with just a few octaves, we'll use it for color\n    noise_input.w = 1337.;\n    n = noise(noise_input) - 0.1;\n    n += (noise(2. * noise_input) - 0.5) * 0.5;\n    n += (noise(4. * noise_input) - 0.5) * 0.25;\n    n = clamp(n, 0., 1.);\n    n = pow(n, 2.0);\n    float b = n;\n\n    // Sample perlin noise for distortion\n    noise_input.w = 9876.;\n    n = noise(noise_input) - 0.1;\n    n += (noise(2. * noise_input) - 0.5) * 0.5;\n    n += (noise(4. * noise_input) - 0.5) * 0.25;\n    n += (noise(8. * noise_input) - 0.5) * 0.125;\n\n    // Mix the new noise with `a` to create fringing around the tentacles\n    float c = n * mix(0.08, 0.4, a);\n    // Distort (re-use `b` as angle)\n    vec2 uvNew = uv;\n    uvNew.x += cos(b) * c;\n    uvNew.y += sin(b) * c;\n    uvNew = mix(uv, uvNew, iIntensity);\n    uvNew = clamp(uvNew, 0., 1.);\n\n    // Make a black-ish/blue-ish color\n    vec4 color = vec4(0.05, 0.4, 0.5, 1.);\n    color.rgb *= b;\n    color.rg *= mix(0.7, 1.0, c);\n    color *= a * smoothstep(0., 0.2, iIntensity);\n\n    vec4 under = texture(iInput, uvNew);\n    fragColor = composite(under, color);\n}\n", 
    "resources/effects/yuvposter.glsl": "#property description Reduce number of colors in YUV space (but keep luminance)\n\nvoid main(void) {\n    //float bins = 256. * pow(2, -8. * iIntensity);\n    float bins = min(256., 1. / iIntensity);\n    \n    // bin in non-premultiplied space, then re-premultiply\n    vec4 c = demultiply(texture(iInput, uv));\n    c.rgb = rgb2yuv(c.rgb);\n    c.gb = clamp(round(c.gb * bins) / bins, 0.0, 1.0);\n    c.rgb = yuv2rgb(c.rgb);\n    fragColor = premultiply(c);\n}\n", 
    "resources/effects/litebrite.glsl": "#property description Pixelate, but circles in a hexagonal grid\n\nvec4 triGrid(mat2 basis) {\n    float points = min(3. / iIntensity, 10000.);\n    float r = 0.5 / points;\n\n    mat2 invBasis = inverse(basis);\n\n    vec2 pt = (uv - 0.5) * aspectCorrection;\n\n    vec2 newCoord = round(pt * points * invBasis);\n    vec2 colorCoord = newCoord / points * basis;\n    vec4 c = texture(iInput, colorCoord / aspectCorrection + 0.5);\n    c *= 1. - step(r, length(pt - colorCoord));\n    return c;\n}\n\nvoid main(void) {\n    const float R3 = sqrt(3.) / 2.;\n    mat2 tri1 = mat2(1., 0.5,\n                     0., R3);\n    mat2 tri2 = mat2(1., -0.5,\n                     0., R3);\n    mat2 tri3 = mat2(-0.5, 0.5,\n                     R3, R3);\n\n    vec4 c1 = triGrid(tri1);\n    vec4 c2 = triGrid(tri2);\n    vec4 c3 = triGrid(tri3);\n    vec4 c = max(max(c1, c2), c3);\n\n    fragColor = texture(iInput, uv);\n    fragColor = mix(fragColor, c, smoothstep(0., 0.1, iIntensity));\n}\n", 
    "resources/effects/zoomin.glsl": "#property description Zoom in\n\nvoid main(void) {\n    float factor = 1.0 - iIntensity;\n    factor = clamp(factor, 0.05, 2.);\n\n    fragColor = texture(iInput, (uv - 0.5) * factor + 0.5);\n}\n", 
    "resources/glsl/crossfader.glsl": "uniform lowp float iParameter;\nvarying highp vec2 coords;\nuniform sampler2D iLeft;\nuniform sampler2D iRight;\n\n// Alpha-compsite two colors, putting one on top of the other\nvec4 composite(vec4 under, vec4 over) {\n    float a_out = 1. - (1. - over.a) * (1. - under.a);\n    return clamp(vec4((over.rgb * over.a  + under.rgb * under.a * (1. - over.a)) / a_out, a_out), vec4(0.), vec4(1.));\n}\n\nvoid main() {\n    vec4 l = texture2D(iLeft, 0.5 * (coords + 1.));\n    vec4 r = texture2D(iRight, 0.5 * (coords + 1.));\n    gl_FragColor = l * (1. - iParameter) + r * iParameter;\n}\n", 
    "resources/effects/wobsphere.glsl": "// Stolen from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// Credit for most of this goes to Jamie Wong\n\n#property description Wobbly drippy sphere that responds to audio\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float STEP_SIZE = 0.7;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n// Displacement based on a single parameter\nfloat disp(float x) {\n    x *= 0.3;\n    float wave = 0.;\n    wave += 1.8 * sin(x * 10. + iTime * 0.1) * iAudioLow;\n    wave += 1.2 * sin(x * 20. + iTime * 0.1) * iAudioMid;\n    wave += 0.6 * sin(x * 70. + iTime * 0.1) * iAudioHi;\n    wave *= iIntensity;\n    return wave;\n}\n\n// Displacement of the sphere at a point p\nfloat dispP(vec3 p) {\n    return disp(p.x) * disp(p.y + iTime) * disp(p.z) * clamp(1. - p.y, 0., 1.);\n}\n\n// The complete SDF\nfloat sceneSDF(vec3 p) {\n    float d = length(p) - iIntensity;\n    return d + dispP(p);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist * STEP_SIZE;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(20.0,\n                          20.0,\n                          20.0);\n    //light1Pos += eye;\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(-20.0,\n                          -20.0,\n                          -20.0);\n\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 dir, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid main()\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, uv * iResolution.xy);\n\n    vec3 eye = vec3(5. * cos(iTime * 0.4), 2., 5. * sin(iTime * 0.4));\n    vec3 dir = -eye;\n\n    mat4 viewToWorld = viewMatrix(eye, dir, vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = texture(iInput, uv) * (1. - smoothstep(0., 0.2, iIntensity));\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n\n    vec2 texCoord = p.zy;\n    texCoord += dispP(p) * normalize(texCoord);\n    texCoord /= max(iIntensity * 1.01, 0.001);\n    texCoord = 0.5 * texCoord + 0.5;\n\n    vec3 texColor = texture(iInput, texCoord).rgb * box(texCoord);\n    vec3 K_a = texColor * 0.3;\n    vec3 K_d = texColor * 1.3;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 40.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n\n    fragColor = vec4(color, 1.0);\n}\n", 
    "resources/effects/yuvblur.glsl": "#property description Horizontal blur of UV channels to give an old-timey effect\n// This effect isn't actually that good...\n\n#define MAX_DELTA 0.04\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec3 yuv = rgb2yuv(demultiply(fragColor).rgb);\n\n    float delta = MAX_DELTA * iIntensity;\n    vec3 left  = rgb2yuv(demultiply(texture(iInput, uv + vec2(-delta, 0))).rgb);\n    vec3 right = rgb2yuv(demultiply(texture(iInput, uv + vec2(+delta, 0))).rgb);\n    yuv.gb = mix(yuv.gb, (left.gb + right.gb) / 2.0, 0.7 * iIntensity);\n    yuv.gb = clamp(yuv.gb, 0., 1.);\n\n    fragColor.rgb = yuv2rgb(yuv) * fragColor.a;\n}\n", 
    "resources/effects/bwave.glsl": "#property description Black sine wave from left to right.\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float x = (normCoord.x + normCoord.y) * 15. + iTime;\n    fragColor = texture(iInput, uv);\n    fragColor *= 1.0 - iIntensity * (0.5 * sin(x) + 0.5);\n}\n", 
    "resources/effects/still.glsl": "#property description Stick chunks to the screen\n\nvoid main(void) {\n    vec4 hold = texture(iChannel[1], uv);\n    vec4 inp = texture(iInput, uv);\n    hold.a = inp.a;\n    hold = premultiply(hold);\n    fragColor = mix(inp, hold, iIntensity);\n}\n\n#buffershader\n\nvoid main(void) {\n    vec4 inp = texture(iInput, uv);\n    inp = premultiply(inp);\n    vec4 hold = texture(iChannel[1], uv);\n\n    float k = hold.a;\n    float d = distance(inp.rgb, hold.rgb) / sqrt(3.);\n\n    k += pow(d, 0.5) * 0.3 - 0.03;\n    k *= pow(iIntensity, 0.3);\n    k = clamp(k, 0., 1.);\n\n    fragColor.rgb = mix(inp.rgb, hold.rgb, k);\n    fragColor.a = k;\n}\n", 
    "resources/effects/flippy.glsl": "#property description Turns the image into tiles and flips each one along a diagonal\n\nvoid main(void) {\n    vec2 timeOffset = vec2(iIntensityIntegral * 0.06) * sign(uv.x + uv.y - 1.);\n    vec2 newPt = (uv - 0.5 - timeOffset) * aspectCorrection;\n\n    float bins = mix(50., 3., iIntensity);\n\n    vec2 newPtInt = floor(newPt * bins);\n    vec2 newPtFrac = fract(newPt * bins);\n\n    newPtFrac = 1. - newPtFrac.yx;\n\n    newPt = (newPtInt + newPtFrac) / bins;\n\n    fragColor = texture(iInput, newPt / aspectCorrection + 0.5 + timeOffset);\n    fragColor = mix(texture(iInput, uv), fragColor, smoothstep(0., 0.1, iIntensity));\n}\n", 
    "resources/effects/negative.glsl": "#property description Invert the image colors\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    fragColor.rgb = mix(fragColor.rgb, fragColor.a - fragColor.rgb, iIntensity);\n}\n", 
    "resources/effects/slide.glsl": "#property description Slide the screen left-to-right\n\nvoid main(void) {\n    float deviation = iIntensityIntegral;\n    vec2 uv2 = (uv - 0.5) * aspectCorrection;\n    uv2.x = abs(mod(uv2.x + deviation + 1.5, 2.) - 1.) - 0.5;\n    uv2  = uv2 / aspectCorrection + 0.5;\n\n    vec4 oc = texture(iInput, uv);\n    vec4 c = texture(iInput, uv2);\n\n    oc *= (1. - smoothstep(0.1, 0.2, iIntensity));\n    c *= smoothstep(0., 0.1, iIntensity);\n\n    fragColor = composite(oc, c);\n}\n", 
    "resources/effects/subpixel.glsl": "#property description Zoomin until you see subpixels\n\nvoid main(void) {\n    vec2 pt = (uv - 0.5) * aspectCorrection;\n    float op = onePixel * 0.3;\n    float factor = exp(-6. * iIntensity);\n\n    vec2 coord = floor(pt * factor / op) * op;\n    vec2 f = fract(pt * factor / op);\n    vec4 c = texture(iInput, coord + 0.5);\n\n    vec4 redSubpixel   = box(vec2(0.0, 0.) + f * vec2(3.6, 1.2)) * vec4(c.r, 0., 0., c.r);\n    vec4 greenSubpixel = box(vec2(-1.2, 0.) + f * vec2(3.6, 1.2)) * vec4(0., c.g, 0., c.g);\n    vec4 blueSubpixel  = box(vec2(-2.4, 0.) + f * vec2(3.6, 1.2)) * vec4(0., 0., c.b, c.b);\n\n    vec4 c2 = redSubpixel + greenSubpixel + blueSubpixel;\n    fragColor = texture(iInput, (uv - 0.5) * factor + 0.5);\n    fragColor = mix(fragColor, c2, smoothstep(0.3, 0.6, iIntensity));\n}\n", 
    "resources/effects/uvmapid.glsl": "#property description Base identity pattern for use with `uvmap`\n\nvoid main(void) {\n    vec4 base = texture(iInput, uv);\n    // The .b channel could be anything; 0.0 plays well with `rainbow`\n    vec4 c = vec4(uv, 0.0, 1.0);\n    fragColor = mix(base, c, iIntensity);\n}\n", 
    "resources/effects/rgbmask.glsl": "#property description Use the R, G, B channels of the first input to mask the other 3 inputs\n#property inputCount 4\n\nvoid main() {\n    vec4 m = texture(iInputs[0], uv);\n    vec4 r = texture(iInputs[1], uv);\n    vec4 g = texture(iInputs[2], uv);\n    vec4 b = texture(iInputs[3], uv);\n\n    fragColor = mix(m, vec4(0.0), iIntensity);\n    m *= iIntensity;\n    fragColor = composite(fragColor, r * m.r);\n    fragColor = composite(fragColor, g * m.g);\n    fragColor = composite(fragColor, b * m.b);\n}\n", 
    "resources/effects/no.glsl": "#property description Reduce alpha (make input go away)\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    fragColor *= (1. - iIntensity);\n}\n", 
    "resources/effects/rotate.glsl": "#property description Rotate the screen\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float r = iIntensity;\n    float s = sin(r * M_PI);\n    float c = cos(r * M_PI);\n    mat2 rot = mat2(c, -s, s, c);\n\n    vec2 newUV = normCoord * rot / aspectCorrection + 0.5;\n\n    fragColor = texture(iInput, newUV);\n    fragColor *= box(newUV);\n}\n", 
    "resources/effects/composite.glsl": "#property description Overlay the second input on top of the first\n#property inputCount 2\nvoid main() {\n    vec4 l = texture(iInputs[0], uv);\n    vec4 r = texture(iInputs[1], uv);\n    fragColor = composite(l, r * iIntensity);\n}\n", 
    "resources/effects/random.glsl": "#property description Snowcrash: white static noise\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    float x = rand(vec4(gl_FragCoord.xy, iTime, 1.));\n    float y = rand(vec4(gl_FragCoord.xy, iTime, 2.));\n    float z = rand(vec4(gl_FragCoord.xy, iTime, 3.));\n    vec4 c = vec4(x, y, z, 1.0);\n    fragColor = mix(fragColor, c, iIntensity);\n}\n", 
    "resources/effects/pixelate.glsl": "#property description Pixelate/quantize the output\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float bs = 256. * pow(2., -9. * iIntensity);\n    vec2 bins = bs * aspectCorrection;\n    normCoord = round(normCoord * bins) / bins;\n\n    vec2 newUV = normCoord / aspectCorrection + 0.5;\n\n    fragColor = texture(iInput, newUV);\n}\n", 
    "resources/effects/gamma.glsl": "#property description Brighten the image using gamma correction\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    fragColor = pow(fragColor, vec4(1. / (1. + iIntensity * 3.)));\n}\n\n", 
    "resources/effects/yellow.glsl": "#property description Yellow and green vertical waves\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    fragColor = texture(iInput, uv);\n\n    float y = smoothstep(0.2, 0.7, abs(mod(normCoord.x * 4. - iIntensityIntegral, 2.) - 1.));\n    float g = smoothstep(0.5, 0.9, abs(mod(1. + normCoord.x * 4. - iIntensityIntegral, 2.) - 1.));\n\n    vec4 c = vec4(1., 1., 0., y);\n    c = composite(c, vec4(0., 1., 0., g * smoothstep(0.5, 0.8, iIntensity)));\n\n    c.a *= smoothstep(0., 0.1, iIntensity);\n    c = clamp(c, 0., 1.);\n    fragColor = composite(fragColor, premultiply(c));\n}\n", 
    "resources/effects/tile.glsl": "#property description Repeating tiles\n\nvoid main(void) {\n    vec2 normCoord = uv - 0.5;\n    float bins = pow(2., 4. * iIntensity);\n    vec2 newUV = normCoord * bins;\n    newUV = mod(newUV + 0.5, 1.) - 0.5;\n    fragColor = texture(iInput, newUV + 0.5);\n}\n", 
    "resources/effects/polygon.glsl": "#property description Convert vertical lines to polygon rings\n\nvoid main(void) {\n    float n_sides = clamp(2.4 / (1. - iIntensity), 3., 10000.);\n    float whole_sides = 0.;\n    n_sides = modf(n_sides, whole_sides);\n    n_sides = whole_sides + smoothstep(0.2, 0.8, n_sides);\n\n    vec2 xy_cent = 2. * uv - 1.;\n    float angle = abs(atan(xy_cent.y, xy_cent.x));\n    float arc = 2. * M_PI / n_sides;\n    float a1 = mod(angle, arc);\n    //float lengthFactor = sqrt(2.);\n    float lengthFactor = 1.0;\n    float corr = cos(a1 - arc / 2.) / (lengthFactor * cos(arc / 2.));\n\n    vec2 rtheta = vec2(length(xy_cent) * corr, 0.5 + angle / (2. * M_PI));\n    vec2 uv2 = mix(uv, rtheta, smoothstep(0., 0.2, iIntensity));\n\n    fragColor = texture(iInput, uv2) * box(uv2);\n}\n", 
    "resources/effects/yuvmapid.glsl": "#property description Identity input for yuvmap\n\nvoid main(void) {\n    // Y could be anything, use 0.5\n    vec2 scaledUV = (uv - 0.5) / 4.0 + 0.5;\n    vec3 yuv = vec3(0.5, scaledUV);\n\n    vec4 base = texture(iInput, uv);\n    vec4 yuvColor = clamp(vec4(yuv2rgb(yuv), 1.0), 0.0, 1.0);\n    fragColor = mix(base, yuvColor, iIntensity);\n}\n\n", 
    "resources/effects/emboss.glsl": "#property description Emboss first input according to second\n#property inputCount 2\n\n// Return the height for a given uv point\nfloat height(vec2 pos) {\n    vec4 c = texture(iInputs[1], pos);\n    float amt = (c.r + c.g + c.b) / 3.;\n    return (amt - 1.) * c.a * 0.03 * iIntensity;\n}\n\n// Estimate the normal of the new displacement-mapped surface\nvec3 estimateNormal() {\n    vec3 pt = vec3(uv, height(uv));\n\n    vec2 EPSILON = 1. / iResolution; // One pixel\n\n    // Take a small step in X\n    vec3 stepX = vec3(EPSILON.x, 0., 0.);\n    stepX.z = height(uv + stepX.xy);\n    stepX = stepX - pt;\n\n    // Take a small step in Y\n    vec3 stepY = vec3(0., EPSILON.y, 0.);\n    stepY.z = height(uv + stepY.xy);\n    stepY = stepY - pt;\n\n    // Return the cross product of these vectors\n    // to get the surface normal\n    return normalize(-cross(stepX, stepY));\n}\n\nvoid main(void) {\n    // Look up the color of the point\n    // (iInputs[0] displaced by a small amount up according to height)\n    vec4 c = texture(iInputs[0], uv + vec2(0., 0.5 * height(uv)));\n\n    // Specular exponent\n    float shininess = 40.;\n\n    // Specular amount\n    float k_spec = iIntensity * 0.5;\n\n    // Diffuse amount\n    float k_diff = 1.3;\n\n    // Ambient amount\n    float k_amb = 0.3;\n\n    // Image is in the Z-plane spanning 0,0 to 1,1\n    vec3 pt = vec3(uv, 0.);\n    vec3 viewer = vec3(0.5, -2., 4.);\n    vec3 light = vec3(0.5, 2., 1.);\n\n    // Blinn-Phong model\n    vec3 n = estimateNormal();\n    vec3 l = normalize(light - pt);\n    vec3 v = normalize(viewer - pt);\n    vec3 h = normalize(l + v); // Halfway vector\n    float spec = pow(dot(n, h), shininess) * k_spec; // Specular component\n    float diff = max(dot(n, l), 0.) * k_diff; // Diffuse component\n\n    // Compute the shaded color of this pixel\n    vec4 shaded = min(c * k_amb + c * diff * k_diff + spec, 1.);\n\n    // Blend between the flat-shaded and phong-shaded colors\n    // to preserve identity\n    fragColor = mix(c, shaded, smoothstep(0., 0.2, iIntensity));\n}\n", 
    "resources/effects/cyan.glsl": "#property description Cyan diagonal stripes\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float t = normCoord.x * 3.0 + normCoord.y * 3.0;\n    float y = smoothstep(0.2, 0.7, abs(mod(t - 3. * iIntensityIntegral, 2.) - 1.));\n    float g = smoothstep(0.5, 0.9, abs(mod(1. + t - 3. * iIntensityIntegral, 2.) - 1.));\n\n    vec4 c = vec4(0., 1., 1., 1.) * y;\n    vec4 d = vec4(0., 0., 1., 1.) * g * smoothstep(0.5, 0.8, iIntensity);\n    c = composite(c, d);\n\n    c *= smoothstep(0., 0.1, iIntensity);\n    c = clamp(c, 0., 1.);\n    fragColor = composite(fragColor, c);\n}\n", 
    "resources/effects/smoky.glsl": "#property description Emit smoke from the object\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c = texture(iChannel[1], uv); // The smoke is stored and drawn on iChannel[1]\n    c *= smoothstep(0., 0.2, iIntensity);\n    fragColor = composite(c, fragColor);\n}\n\n#buffershader\n\n// Create a 1/r circulating vector field\n// using the given matrix transform\n\nvec2 circulate(mat3 xf) {\n    // Calculate transformed point\n    vec2 pt = (vec3(uv, 1.) * xf).xy;\n\n    // Create circulating vector field\n    // with the appropriate magnitude\n    float l = length(pt);\n    vec2 val = 0.01 * pt * mat2(0., 1., -1., 0.) / (l * l);\n\n    // Prevent weirdness in the center\n    val *= smoothstep(0., 0.1, l);\n    return val;\n}\n\n// Create a compelling circulating vector field\nvec2 vectorField() {\n    vec2 field = vec2(0.);\n\n    // Combine three calls to circulate()\n    for (int i=0; i<3; i++) {\n        vec4 n = texture2D(iNoise, vec2(0.5 + float(i) / 20., 0.5 + iIntensityIntegral * 0.00006));\n\n        // Random xy scaling\n        float sx = 5. * (n.b - 0.5) * iIntensity;\n        float sy = 5. * (n.a - 0.5) * iIntensity;\n\n        // Random xy translation as well\n        mat3 xf = mat3(sx, 0., -n.r * sx,\n                       0., sy, -n.g * sy,\n                       0., 0., 1.);\n\n        // Superimpose\n        field += circulate(xf);\n    }\n\n    // Give a slight bit of divergence\n    field -= (uv - 0.5) * iIntensity * iIntensity * 0.3;\n    return field;\n}\n\nvoid main(void) {\n    float dt = 0.01;\n\n    // Nudge according to vector field\n    fragColor = texture(iChannel[1], uv + vectorField() * dt);\n\n    // Fade out\n    fragColor *= exp((iIntensity - 2.) / 300.);\n\n    // Clear when intensity is zero\n    fragColor *= smoothstep(0., 0.1, iIntensity);\n\n    // Desaturate\n    float avgRGB = (fragColor.r + fragColor.g + fragColor.b) / 3.;\n    fragColor.rgb = mix(fragColor.rgb, vec3(avgRGB), 0.05);\n\n    // Composite with input\n    vec4 c = texture(iInput, uv);\n    fragColor = composite(fragColor, c);\n}\n", 
    "resources/effects/desat.glsl": "#property description Desaturate in YUV space\n\nvoid main(void) {\n    float factor = pow(iIntensity, 3.);\n\n    vec4 samp = demultiply(texture(iInput, uv));\n\n    //vec3 hsl = rgb2hsv(samp.rgb);\n    //hsl.g *= 1.0 - factor;\n    //fragColor.rgb = hsv2rgb(hsl);\n\n    vec3 yuv = rgb2yuv(samp.rgb);\n    yuv.gb -= 0.5;\n    yuv.gb *= 1.0 - factor;\n    yuv.gb += 0.5;\n    fragColor.rgb = yuv2rgb(yuv);\n\n    fragColor.a = samp.a;\n    fragColor = premultiply(fragColor);\n}\n", 
    "resources/effects/tunnel.glsl": "#property description 3D tunnel\n#property author https://www.shadertoy.com/view/4sXSzs\n\nvoid main()\n{\n\tvec2 q = (uv - vec2(0.5, 0.5)) * aspectCorrection;\n\n    float t2 = iTime * 0.2;\n    vec2 offset = vec2(sin(t2), cos(t2)) * 0.2;\n    q -= offset;\n\n\tfloat len = length(q);\n\n    float t = iIntensityIntegral * 3.;\n\tfloat a = 6. * atan(q.y, q.x) / (2. * M_PI) + t * 0.3;\n\tfloat b = 6. * atan(q.y, q.x) / (2. * M_PI) + t * 0.3;\n\tfloat r1 = 0.3 / len + t * 0.5;\n\tfloat r2 = 0.2 / len + t * 0.5;\n\n    vec2 texcoords = vec2(a + 0.1 / len, r1);\n\tvec4 tex1 = texture(iInput, abs(mod(texcoords, 2.) - 1.));\n    vec4 c = tex1 * smoothstep(0., 0.1, len);\n    c *= smoothstep(0.1, 0.2, iIntensity);\n\n    vec2 texcoords2 = (uv - 0.5 - offset) / (1. - smoothstep(0., 0.2, iIntensity)) + 0.5 + offset;\n    vec4 c2 = texture(iInput, texcoords2);\n    c2 *= box(texcoords2);\n\n    fragColor = composite(c2, c);\n}\n\n", 
    "resources/effects/kmeans.glsl": "#property description k-means clustering? (idk)\n\nvoid main(void) {\n    vec2 uvCluster = texture(iChannel[1], uv).xy;\n    vec2 uvNew = mix(uv, uvCluster, clamp(iIntensity * 2., 0., 1.0));\n    fragColor = texture(iInput, uvNew);\n    //fragColor = texture(iChannel[1], uv);\n}\n\n#buffershader\n\nfloat distFn(vec4 x, vec4 y) {\n    vec3 v = demultiply(x).xyz - demultiply(y).xyz;\n    v = abs(v);\n    //float d = v.x + v.y + v.z;\n    float d = length(v);\n    return d;\n    //return 1. / (0.0001 + d);\n}\n\nvoid main(void) {\n    //float q = pow(2.0, floor(rand(vec3(uv, iTime)) * 4));\n    float q = 1.;\n    vec2 a = uv;\n    vec2 b = texture(iChannel[1], uv).xy;\n    //vec2 a = texture(iChannel[1], uv + onePixel * vec2( 5,  5)).xy;\n    //vec2 b = texture(iChannel[1], uv + onePixel * vec2(-5, -5)).xy;\n    vec2 c = texture(iChannel[1], uv + onePixel * vec2( q,  q)).xy;\n    vec2 d = texture(iChannel[1], uv + onePixel * vec2( q, -q)).xy;\n    vec2 e = texture(iChannel[1], uv + onePixel * vec2(-q,  q)).xy;\n    vec2 f = texture(iChannel[1], uv + onePixel * vec2(-q, -q)).xy;\n\n    vec4 av = texture(iInput, a);\n    vec4 bv = texture(iInput, b);\n    vec4 cv = texture(iInput, c);\n    vec4 dv = texture(iInput, d);\n    vec4 ev = texture(iInput, e);\n    vec4 fv = texture(iInput, f);\n\n    vec4 mean = (av + bv + cv + dv + ev + fv) / 6.0;\n\n    float ad = distFn(av, mean);\n    float bd = distFn(bv, mean);\n    float cd = distFn(cv, mean);\n    float dd = distFn(dv, mean);\n    float ed = distFn(ev, mean);\n    float fd = distFn(fv, mean);\n\n    float minDist = min(min(min(ad, bd), min(cd, dd)), min(ed, fd));\n\n    float af = ad == minDist ? 1.0 : 0.0;\n    float bf = bd == minDist ? 1.0 : 0.0;\n    float cf = cd == minDist ? 1.0 : 0.0;\n    float df = dd == minDist ? 1.0 : 0.0;\n    float ef = ed == minDist ? 1.0 : 0.0;\n    float ff = fd == minDist ? 1.0 : 0.0;\n    float fsum = af + bf + cf + df + ef + ff;\n    vec2 uvNew = (a * af + b * bf + c * cf + d * df + e * ef + f * ff) / (af + bf + cf + df + ef + ff);\n\n    fragColor = vec4(uvNew, min(1.0, fsum * 0.5), 1.0);\n    //fragColor = mean;\n}\n", 
    "resources/effects/life.glsl": "#property description Game of life?\n\nvoid main(void) {\n    float alive = texture(iChannel[1], uv).r;\n    vec4 under = texture(iInput, uv);\n    vec4 over = alive * texture(iChannel[2], uv);\n    over *= smoothstep(0., 0.2, iIntensity);\n    fragColor = composite(under, over);\n}\n\n#buffershader\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    //float bs = 2048. * pow(2, -5. * iIntensity);\n    float bs = max((1. - iIntensity) / (1.3 * onePixel), 5.);\n    vec2 bins = bs * aspectCorrection;\n    vec2 db = 1. / (bins * aspectCorrection);\n    normCoord = round(normCoord * bins) * db + 0.5;\n\n    float n = 0.;\n    n += texture(iChannel[1], normCoord + db * vec2(-1, -1)).r;\n    n += texture(iChannel[1], normCoord + db * vec2(-1,  0)).r;\n    n += texture(iChannel[1], normCoord + db * vec2(-1,  1)).r;\n    n += texture(iChannel[1], normCoord + db * vec2( 0, -1)).r;\n    n += texture(iChannel[1], normCoord + db * vec2( 0,  1)).r;\n    n += texture(iChannel[1], normCoord + db * vec2( 1, -1)).r;\n    n += texture(iChannel[1], normCoord + db * vec2( 1,  0)).r;\n    n += texture(iChannel[1], normCoord + db * vec2( 1,  1)).r;\n    float s = texture(iChannel[1], normCoord).r;\n\n\n    // Use bright areas of the source image to help \"birth\" pixels (or kill)\n    vec4 source = texture(iInput, normCoord);\n    //float r = 20. * rand(vec3(normCoord, iTime)) + mix(4.0, 0, iIntensity);\n    //float bonus = step(20.5, r + max(max(source.r, source.g), source.b));\n    //n += bonus * 3;\n\n    // if (s == 0) { alive = (n == 3) }\n    // else { alive = (2 <= n <= 3) }\n    float alive = step(1.8, n) * step(n, 3.2) * step(2.8, n + s);\n    alive *= step(0.05, iIntensity); // to reset\n\n    // Make there be life if there is sufficient input color\n    //float lifeFromInput = step(0.5, smoothstep(0., 3., dot(vec3(1.), source.rgb)));\n    float lifeFromInput = step(0.8, max(source.r, max(source.g, source.b)));\n    alive = max(alive, lifeFromInput);\n    alive *= step(0.01, texture(iChannel[2], normCoord).a); // Kill stable life if there is no color\n\n    fragColor.gba = vec3(1.0);\n    fragColor.r = alive;\n}\n\n#buffershader\n\n// This buffer just paints the world so that life can extend\n// outside of what currently has color\n\nvoid main(void) {\n    vec4 oldC = texture(iChannel[2], uv);\n    float d = mix(0.01, 0.001, iIntensity);\n    oldC = max(oldC - d, vec4(0.));\n    vec4 newC = texture(iInput, uv);\n    fragColor = max(oldC, newC);\n}\n", 
    "resources/effects/cycle2.glsl": "#property description Switch between the two inputs on the beat\n#property inputCount 2\nvoid main() {\n    vec4 l = texture(iInputs[0], uv);\n    vec4 r = texture(iInputs[1], uv);\n\n    float amt = mix(1., 8., iIntensity);\n    float switcher = 0.5 * clamp(amt * sin(0.5 * iTime * M_PI), -1., 1.) + 0.5;\n\n    float which = mix(0., switcher, smoothstep(0., 0.1, iIntensity));\n    which = mix(which, 1., smoothstep(0.9, 1., iIntensity));\n\n    fragColor = mix(l, r, which);\n}\n", 
    "resources/effects/wwave.glsl": "#property description White wave with hard edges\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float xpos = iIntensityIntegral * .5;\n    float xfreq = (iIntensity + 0.5) * 2.;\n    float x = mod(normCoord.x * xfreq + xpos, 1.);\n    fragColor = texture(iInput, uv);\n    vec4 c = vec4(1., 1., 1., step(x, 0.3) * smoothstep(0., 0.5, iIntensity));\n    fragColor = composite(fragColor, premultiply(c));\n}\n", 
    "resources/effects/uvmap.glsl": "#property description Use .rg as .uv and crossfade\n\n#property inputCount 2\nvoid main(void) {\n    vec4 map = texture(iInputs[1], uv);\n    vec2 newUV = mix(uv, map.rg, min(iIntensity * 2.0, 1.0) * map.a);\n    vec4 mappedColor = texture(iInput, newUV);\n    fragColor = mix(mappedColor, map, max(0.0, iIntensity * 2.0 - 1.0));\n}\n", 
    "resources/effects/maze.glsl": "// Stolen from https://www.shadertoy.com/view/XsdGzM\n// and http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// Credit for most of this goes to Edd Biddulph and Jamie Wong\n\n#property description 3D maze\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat myNoise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n// This is not quite right but it is OK\nfloat mazeDist(vec3 p) {\n    vec3 cp=fract(p)-vec3(.5),acp=abs(cp);\n    vec2 p2 = p.xz * mat2(1, 1, 1, -1);\n    vec2 c = floor(p2), f = p2 - c;\n    float a = step(.5, noise(c));\n    float s = 0.05;\n    if(a>.5)\n        return acp.x-s;\n    return acp.z-s;\n}\n\nfloat sceneSDF(vec3 p) {\n\treturn max(mazeDist(p), abs(p.y) - smoothstep(0., 0.3, iIntensity) * 0.5 + EPSILON);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(40.0 * sin(iTime),\n                          20.0,\n                          40.0 * cos(iTime));\n    //light1Pos += eye;\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(20.0 * sin(0.37 * iTime),\n                          20.0 * cos(0.37 * iTime),\n                          -20.0);\n\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 dir, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid main()\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, uv * iResolution.xy);\n    vec3 eye = vec3(30. * cos(iTime * 0.1), 2., 30. * sin(iTime * 0.03));\n    vec3 dir = vec3(30. * 0.1 * -sin(iTime * 0.1), -1., 30. * 0.03 * cos(iTime * 0.03));\n\n    eye = mix(vec3(0., 50., 0.), eye, iIntensity);\n    dir = mix(vec3(0.01, -1., 0.), dir, iIntensity);\n\n    mat4 viewToWorld = viewMatrix(eye, dir, vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = texture(iInput, uv) * (1. - smoothstep(0., 0.2, iIntensity));\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 voxCoord = fract(p - 0.5) - 0.5;\n    vec2 texCoord;\n    if (abs(voxCoord.z) > abs(voxCoord.x)) {\n    \ttexCoord = voxCoord.xy;\n    } else {\n    \ttexCoord = voxCoord.zy;\n    }\n    texCoord += 0.5;\n    \n    vec3 texColor = texture(iInput, texCoord).rgb;\n    vec3 K_a = texColor * 0.3;\n    vec3 K_d = texColor;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n\n    fragColor = vec4(color, 1.0);\n}\n", 
    "resources/glsl/plain_vertex.glsl": "attribute vec4 vPosition;\nvarying highp vec2 uv;\nvoid main() {\n    gl_Position = vec4(vPosition.xy, 1., 1.);\n    uv = vPosition.zw;\n}\n", 
    "resources/effects/invertl.glsl": "#property description Invert the image lightness, preserving color\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec3 hsv = rgb2hsv(fragColor.rgb);\n    hsv.z = fragColor.a - hsv.z;\n    fragColor.rgb = mix(fragColor.rgb, hsv2rgb(hsv), iIntensity);\n}\n", 
    "resources/effects/solitaire.glsl": "#property description That cool thing that happens when you beat solitaire\n\nvoid main(void) {\n    // Relative size of the bouncing image\n    // I don't think we need to encorporate aspectCorrection?\n    float scale = mix(1.0, 0.25, smoothstep(0., 0.3, iIntensity));\n\n    // Closed-form bouncing behavior\n    // I think this is periodic over [0.0, 16.] to prevent discontinuities\n    vec2 xy = vec2(sawtooth(iStep * 0.3125, 0.5), 1.0 - abs(sin(iStep * M_PI * 0.5625)));\n\n    xy = (xy - 0.5) * (1.0 - scale);\n    vec2 uvSample = (uv - 0.5 + xy) / scale + 0.5;\n\n    vec4 c = texture(iInput, uvSample) * box(uvSample);\n    vec4 under = texture(iChannel[0], uv) * smoothstep(0., 0.1, iIntensity);\n    fragColor = composite(under, c);\n}\n", 
    "resources/effects/stripey.glsl": "#property description Vertical stripes with a twinkle effect\n\nvoid main(void) {\n    float xv = round(uv.x * 20. * aspectCorrection.x); \n    fragColor = texture(iChannel[0], uv);\n    fragColor *= exp(-iIntensity / 20.);\n\n    if (rand(vec2(xv, iTime)) < exp(-iIntensity * 4.)) {\n        fragColor = texture(iInput, uv);\n    }\n}\n", 
    "resources/effects/circle.glsl": "#property description Yellow blob that spins to the beat\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float t = iTime / 4.0;\n    vec2 center = vec2(sin(t), cos(t));\n    //center *= 0.5;\n    center *= iAudioLevel * 0.9 + 0.1;\n\n    vec4 c = vec4(1., 1., 0., 1.);\n    c.a = clamp(length(center - normCoord), 0., 1.);\n    c.a = pow(c.a, iAudioHi * 3. + 0.1);\n    c.a = 1.0 - c.a;\n    c.a *= iIntensity;\n\n    fragColor = composite(texture(iInput, uv), premultiply(c));\n}\n", 
    "resources/effects/filmstop.glsl": "#property description De-sync the shutter and the film feed\n\nvoid main(void) {\n\n    // Lookup what offset to display the picture at\n    float offset = texture(iChannel[1], vec2(0.5, 0.5)).r;\n\n    // Display the frame from iChannel[2] at that offset\n    vec4 c = texture(iChannel[2], mod(uv + vec2(0., offset), 1.));\n\n    fragColor = c;\n}\n\n#buffershader\n\n// This shader integrates iIntensity\n// on a per-frame basis\n// to maintain vsync\n// (all pixels are the same color)\n\nvoid main(void) {\n    float v = mod(texture(iChannel[1], vec2(0.5, 0.5)).r - iIntensity, 1.);\n\n    // If intensity is low, decay to zero\n    v = max(0., v - 0.02 * (1. - step(0.03, iIntensity)));\n\n    fragColor = vec4(v);\n}\n\n#buffershader\n\n// This shader mirrors the input when intensity is low,\n// and freezes the frame more and more as the intensity increases\n\nvoid main(void) {\n    float freeze = step(0.8, iIntensity);\n    fragColor = mix(texture(iInputs[0], uv), texture(iChannel[2], uv), freeze);\n}\n", 
    "resources/effects/stripes.glsl": "#property description Dense diagonal white wave with hard edges\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float xpos = iIntensityIntegral * 1.;\n    float xfreq = (iIntensity + 0.2) * 30.;\n    float x = mod((normCoord.x + normCoord.y) * xfreq + xpos, 1.);\n    fragColor = texture(iInput, uv);\n    vec4 c = vec4(1.) * step(x, 0.5) * smoothstep(0., 0.2, iIntensity);\n    fragColor = composite(fragColor, c);\n}\n", 
    "resources/effects/cube.glsl": "#property description 3D cube\n\n// From maze.glsl\nmat4 viewMatrix(vec3 eye, vec3 dir, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// Draw a copy of the input filling the given quad\nvec4 draw(vec2 bottomLeft, vec2 bottomRight, vec2 topLeft, vec2 topRight) {\n    float ssi = smoothstep(0., 0.2, iIntensity);\n\n    // Four-point projection taken from https://math.stackexchange.com/a/339033\n    // Step 1: Compute b in a * e = d\n    mat3 a = mat3(vec3(bottomLeft, 1.),\n                  vec3(bottomRight, 1.),\n                  vec3(topLeft, 1.));\n    vec3 d = vec3(topRight, 1.);\n    // TODO inverse can be replaced with adjugate\n    vec3 e = inverse(a) * d;\n\n    // Step 2: Scale matrix a by e\n    a[0] *= e.x;\n    a[1] *= e.y;\n    a[2] *= e.z;\n\n    // Step 3: Compute the matrix B\n    // which is a constant, so just write it down\n    mat3 b = mat3(0., 0., -1.,\n                  1., 0.,  1.,\n                  0., 1.,  1.);\n\n    // Step 4, 5: Get the combined matrix transform c\n    // TODO inverse can be replaced with adjugate\n    mat3 c = b * inverse(a);\n\n    // Step 6: Project the point uv using transform c\n    vec3 h = c * vec3((uv - 0.5) * mix(vec2(1.), aspectCorrection, ssi), 1.);\n\n    // Step 7: De-homogenize\n    vec2 newUV = h.xy / h.z;\n\n    // Crop the output square if its not\n    vec2 squareUV = (newUV - 0.5) / aspectCorrection + 0.5;\n\n    return texture(iInput, mix(newUV, squareUV, ssi)) * box(newUV);\n}\n\nvoid main() {\n    float ssi = smoothstep(0., 0.4, iIntensity);\n\n    vec3 cubePoints[8] = vec3[](\n        vec3(-1., -1.,  1.),\n        vec3( 1., -1.,  1.),\n        vec3(-1.,  1.,  1.),\n        vec3( 1.,  1.,  1.),\n        vec3(-1., -1., -1.),\n        vec3( 1., -1., -1.),\n        vec3(-1.,  1., -1.),\n        vec3( 1.,  1., -1.)\n    );\n\n    // Indices into cubePoints\n    ivec4 faces[6] = ivec4[](\n        ivec4(0, 1, 2, 3), // Front\n        ivec4(1, 5, 3, 7), // Right\n        ivec4(2, 3, 6, 7), // Top\n        ivec4(5, 4, 7, 6), // Back\n        ivec4(4, 0, 6, 2), // Left\n        ivec4(4, 5, 0, 1) // Bottom\n    );\n\n    // Perspective\n    // TBH I don't actually know how perspective works\n    float p = -0.2 * ssi;\n\n    // Zoom\n    float z = mix(0.5, 0.2, sqrt(ssi));\n\n    mat4 xf = mat4(z,  0., 0., 0.,\n                   0., z,  0., 0.,\n                   0., 0., z,  p,\n                   0., 0., 0., 1.);\n\n    float t = iIntensityIntegral * 1.;\n    vec3 eye = vec3(sin(t), sin(0.5 * t), cos(t));\n    eye = mix(vec3(0., 0., 1.), eye, ssi);\n    // TODO inverse can be replaced with adjugate\n    xf = xf * inverse(viewMatrix(eye, -eye, vec3(0., 1., 0.)));\n\n    // Use the transformation matrix xf to project cubePoints\n    for(int i=0; i<8; i++) {\n        vec4 h = xf * vec4(cubePoints[i], 1.);\n        cubePoints[i].xy = h.xy / h.w;\n        cubePoints[i].z = h.z; // Don't project z, we will use that for occlusion checking\n    }\n\n    // From https://stackoverflow.com/a/749206\n    // BUBBLE SORT\n    // so that we draw in the right order\n    for(int n = 5; n != 0; n--) {\n        for(int i = 0; i < n; i++) {\n            // Compare the center of each cube face\n            if(cubePoints[faces[i].x].z + cubePoints[faces[i].w].z\n            >  cubePoints[faces[i+1].x].z + cubePoints[faces[i+1].w].z) {\n                ivec4 tmp = faces[i];\n                faces[i] = faces[i+1];\n                faces[i+1] = tmp;\n            }\n        }\n    }\n\n\n    // Draw the six faces\n    fragColor = vec4(0.);\n\n    for(int i=0; i<6; i++) {\n        ivec4 face = faces[i];\n        float adj = i == 0 ? smoothstep(0., 0.1, iIntensity) : 1.;\n        fragColor = composite(fragColor, draw(cubePoints[face.x].xy, cubePoints[face.y].xy, cubePoints[face.z].xy, cubePoints[face.w].xy) * adj);\n    }\n}\n", 
    "resources/effects/rfuzz.glsl": "#property description Radial fuzz based on audio\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float a = atan(normCoord.y, normCoord.x);\n    float l = length(normCoord);\n\n    float wave = 0.;\n    // As long as all of the multiplicitive factors on \"a\"\n    // are integers, there will be no discontinuities\n    wave += 0.24 * sin(a * 5. + iTime * 1.) * iAudioLow;\n    wave += 0.24 * sin(a * 7. + iTime * -0.3) * iAudioLow;\n    wave += 0.06 * sin(a * 40. + iTime * 8.) * iAudioMid;\n    wave += 0.06 * sin(a * 70. + iTime * -3.) * iAudioLow;\n    wave += 0.03 * sin(a * 120. + iTime * 16.) * iAudioHi;\n    wave += 0.03 * sin(a * 180. + iTime * -10.) * iAudioHi;\n    wave *= iAudioLevel;\n    wave *= iIntensity;\n\n    // Avoid discontinuities in the center\n    wave *= smoothstep(0., 0.2, l);\n\n    // Avoid going past the edges\n    vec2 extra = 0.5 * (aspectCorrection - 1.);\n    vec2 edgeFadeOut = (1. - smoothstep(0.4 + extra, 0.5 + extra, abs(normCoord)));\n    wave *= edgeFadeOut.x * edgeFadeOut.y;\n\n    // Move radially by \"wave\" amount\n    vec2 offset = normalize(normCoord) * wave;\n\n    fragColor = texture(iInput, (normCoord + offset) / aspectCorrection + 0.5);\n}\n\n", 
    "resources/effects/ltohs.glsl": "#property description Set the hue and saturation equal to the lightness in HSV space\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec3 hsv = rgb2hsv(fragColor.rgb);\n    hsv.x = mix(hsv.x, hsv.z, smoothstep(0., 0.5, iIntensity));\n    hsv.y = mix(hsv.y, hsv.z, smoothstep(0.5, 1.0, iIntensity));\n    fragColor.rgb = hsv2rgb(hsv);\n}\n", 
    "resources/effects/fractalzoom.glsl": "#property description Overlays a smaller pattern and zoom in on it\n\n#define N_COPIES 5\n\nvec4 lookup(float scale) {\n    vec2 newUV = (uv - 0.5) * scale + 0.5;\n    return texture(iInput, newUV) * box(newUV);\n}\n\nvoid main(void) {\n    float scaleReduction = 15. * iIntensity + 1.;\n    float t = mod(-iIntensityIntegral * 0.5, 1.);\n    float scale = pow(scaleReduction, t - 2.);\n    fragColor = lookup(scale) * t;\n    scale *= scaleReduction;\n    for (int i=0; i<N_COPIES - 2; i++) {\n        fragColor = composite(fragColor, lookup(scale));\n        scale *= scaleReduction;\n    }\n    fragColor = composite(fragColor, lookup(scale) * (1. - t));\n    scale *= scaleReduction;\n}\n", 
    "resources/effects/rainblur.glsl": "#property description Rainbow radial blur\n\n#define DEPTH 16\n\nvec4 lookup(vec2 coord) {\n    return texture(iInput, coord / aspectCorrection + 0.5);\n}\n\nvoid main() {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2  d = iIntensity * -normCoord / 200.;\n    float w = iIntensity * 4. / float(DEPTH);\n    vec2  s = normCoord;\n    vec4 col = lookup(s);\n    float deltaHue = 1. / float(DEPTH);\n    for( int i=0; i<DEPTH; i++ )\n    {\n        w *= .9;\n        s += d;\n        vec4 res = lookup(s);\n        //res = smoothstep(0., 1., res); // Makes colors more vibrant\n        res *= max(res.r, max(res.g, res.b));\n        res *= w;\n        res.xyz = rgb2hsv(res.rgb); // TODO this would probably be made much faster using a buffershader of the input converted to HSV\n        res.x = mod(res.x + float(i) * deltaHue - 0.5 * iIntensityIntegral, 1.);\n        res.rgb = hsv2rgb(res.xyz);\n        col = composite(col, res);\n    }\n\n    // This composition results in some saturation loss,\n    // so resaturate\n    vec3 hsv = rgb2hsv(col.rgb);\n    hsv.y = pow(hsv.y, (2. - iIntensity) / 2.);\n    col.rgb = hsv2rgb(hsv);\n\n\tfragColor = col;\n}\n", 
    "resources/effects/yuvmap.glsl": "#property description Use UV (from YUV) as .uv and crossfade\n\n#property inputCount 2\nvoid main(void) {\n    vec4 map = texture(iInputs[1], uv);\n    vec3 yuv = rgb2yuv(demultiply(map).rgb);\n    vec2 scaledUV = (yuv.gb - 0.5) * 4.0 + 0.5;\n    vec2 newUV = mix(uv, scaledUV, min(iIntensity * 2.0, 1.0) * map.a);\n    vec4 mappedColor = texture(iInput, newUV);\n    fragColor = mix(mappedColor, map, max(0.0, iIntensity * 2.0 - 1.0));\n}\n", 
    "resources/effects/bstrobe.glsl": "#property description Full black strobe. Intensity increases frequency\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c;\n\n    float freq;\n    if(iIntensity < 0.05) freq = 0.;\n    else if(iIntensity < 0.15) freq = 4.;\n    else if(iIntensity < 0.25) freq = 2.;\n    else if(iIntensity < 0.35) freq = 1.;\n    else if(iIntensity < 0.45) freq = 0.5;\n    else if(iIntensity < 0.55) freq = 0.25;\n    else if(iIntensity < 0.65) freq = 0.125;\n    else if(iIntensity < 0.75) freq = 0.0625;\n    else freq = 0.03125;\n\n    if(freq > 0.) {\n        c = vec4(0., 0., 0., 1.) * (1. - mod(iTime, freq) / freq);\n        fragColor = composite(fragColor, c);\n    }\n}\n", 
    "resources/effects/uvmapplain.glsl": "#property description Use .rg as .uv without crossfading\n\n#property inputCount 2\nvoid main(void) {\n    vec4 map = texture(iInputs[1], uv);\n    vec2 newUV = mix(uv, map.rg, iIntensity * map.a);\n    fragColor = texture(iInput, newUV);\n}\n", 
    "resources/effects/droste.glsl": "#property description Droste effect (spiral forever!)\n#property author http://roy.red/droste-.html + zbanks\n\n\n// Complex functions from http://glslsandbox.com/e#5664.1\n\nvec2 cconj(const vec2 c) { return vec2(c.x, -c.y); }\n\nvec2 cmul(const vec2 c1, const vec2 c2)\n{\n\treturn vec2(\n\t\tc1.x * c2.x - c1.y * c2.y,\n\t\tc1.x * c2.y + c1.y * c2.x\n\t);\n}\n\nvec2 cdiv(const vec2 c1, const vec2 c2)\n{\n\treturn cmul(c1, cconj(c2)) / dot(c2, c2);\n}\n\nvec2 clog (const vec2 z)\n{\n\treturn vec2 (log(length(z)), atan(z.y, z.x));\n}\n\nvec2 circle (float a) { return vec2 (cos(a), sin(a)); }\n\nvec2 cexp (const vec2 z)\n{\n\treturn circle(z.y) * exp(z.x);\n}\n\nfloat r1 = 0.1;\nfloat r2 = 2.0;\nvec2 droste(vec2 z) {\n    // 4. Take the tiled strips back to ordinary space.\n    z = clog(z);\n    // 3. Scale and rotate the strips\n    float scale = log(r2/r1);\n    // Negate the angle to twist the other way\n    float angle = atan(scale/(2.0*M_PI));\n    z = cdiv(z, cexp(vec2(0,angle))*cos(angle)); \n    // 2. Tile the strips\n    z.x -= iIntensityIntegral * 2.;\n    z.x = mod(z.x,scale);\n    // 1. Take the annulus to a strip\n    z = cexp(z)*r1;\n    z /= r2 * 2.0;\n    return z;\n}\n\nfloat f(float x,float n){\n    return pow(n,-floor(log(x)/log(n)));\n}\nvec2 droste2(vec2 z) {\n    float ratio = 5.264;\n    float angle = atan(log(ratio)/(2.0*M_PI));\n    z = cexp(cdiv(clog(z), cexp(vec2(0,angle))*cos(angle)));\n    vec2 a_z = abs(z);\n    z *= f(max(a_z.x,a_z.y)*2.,ratio);\n    return z / ratio;\n}\n\nvoid main(void) {\n    vec2 normCoord = 2. * (uv - 0.5) * aspectCorrection;\n    vec2 newUV = droste(normCoord);\n    newUV = newUV / aspectCorrection + 0.5;\n\n    fragColor = texture(iInput, mix(uv, newUV, smoothstep(0., 0.2, iIntensity)));\n}\n", 
    "resources/effects/vu.glsl": "#property description Blue vertical VU meter\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    vec3 audio = vec3(iAudioLow, iAudioMid, iAudioHi);\n\n    audio = audio * 2. * iIntensity;\n\n    vec3 draw = 1. - smoothstep(audio - onePixel, audio, vec3(abs(normCoord.x)));\n    vec4 dLow = vec4(0.0, 0.0, 0.5, 1.0) * draw.x;\n    vec4 dMid = vec4(0.0, 0.0, 1.0, 1.0) * draw.y;\n    vec4 dHi  = vec4(0.3, 0.3, 1.0, 1.0) * draw.z;\n\n    vec4 c = composite(composite(dLow, dMid), dHi);\n    c = clamp(c, 0., 1.);\n    fragColor = composite(fragColor, c);\n}\n", 
    "resources/effects/lpass.glsl": "#property description Pass-thru when there are \"lows\" in the music\n\nvoid main(void) {\n    float k = iAudioLow * 2.;\n    fragColor = texture(iInput, uv) * mix(1., min(k, 1.), iIntensity);\n}\n", 
    "resources/effects/rblurb.glsl": "#property description Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Modified for Radiance by Eric Van Albert\n\n#define DEPTH 64\n\nvec4 lookup(vec2 coord) {\n    return texture(iInput, coord / aspectCorrection + 0.5);\n}\n\nvoid main() {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2  d = -normCoord / float(DEPTH);\n    float w = iIntensity * iAudioLow * 7. / float(DEPTH);\n    vec2  s = normCoord;\n    vec4 col = lookup(s);\n    for( int i=0; i<DEPTH; i++ )\n    {\n        w *= .99;\n        s += d;\n        vec4 res = lookup(s);\n        //res = smoothstep(0., 1., res); // Makes colors more vibrant\n        res *= max(res.r, max(res.g, res.b));\n        res *= w;\n        col = composite(col, res);\n    }\n\n\tfragColor = col;\n}\n", 
    "resources/effects/qcircle.glsl": "#property description Big purple soft circle \n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float t = iTime / 4.0;\n    vec2 center = vec2(sin(t), cos(t));\n    center *= 0.5;\n\n    vec4 c = vec4(0.2, 0.1, 0.5, 1.);\n    c.a = clamp(length(center - normCoord), 0., 1.);\n    c.a = pow(c.a, 2.);\n    c.a = 1.0 - c.a;\n    c.a *= iIntensity;\n    c.rgb *= c.a;\n\n    fragColor = composite(texture(iInput, uv), c);\n}\n", 
    "resources/effects/randy.glsl": "#property description Obnoxiously zoom and rotate ( in honor of  Raaaaandy Seidman )\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float theta = 0.3 * (sin(iIntensityIntegral * 0.6) - sin(2. * iIntensityIntegral * 0.6)) * iIntensity;\n    float zoom = 1. + 0.2 * (-1. + sin(iIntensityIntegral * 0.35) - sin(2. * iIntensityIntegral * 0.35)) * iIntensity;\n\n    float s = sin(theta) / zoom;\n    float c = cos(theta) / zoom;\n    mat2 rot = mat2(c, -s, s, c);\n\n    vec2 newUV = normCoord * rot;\n    newUV = newUV / aspectCorrection + 0.5;\n\n    vec4 nc = texture(iInput, newUV);\n    nc *= box(newUV);\n\n    fragColor = nc;\n}\n", 
    "resources/effects/wave.glsl": "#property description Green and blue base pattern\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec4 c = vec4(0., 0., 0., 1.);\n    float ratio = 15.;\n    c.r = 0.0;\n    c.g = 0.5 * sin((normCoord.x + normCoord.y) * ratio) + 0.5;\n    c.b = 0.5 * sin((normCoord.x - normCoord.y) * ratio) + 0.5;\n    c.a = 1.0;\n\n    fragColor = composite(texture(iInput, uv), c * iIntensity);\n}\n", 
    "resources/effects/afix.glsl": "#property description Fix out-of-bounds values in premultiplied-alpha space\n\nvoid main(void) {\n    vec4 c = texture(iInput, uv);\n    float a = max(max(c.r,c.g),max(c.b,c.a));\n    fragColor = vec4(c.rgb,mix(c.a,a,iIntensity));\n}\n", 
    "resources/effects/tesselate.glsl": "#property description Repeating tiles, flipped so that the pattern tesselates\n\nvoid main(void) {\n    vec2 normCoord = uv - 0.5;\n    float bins = pow(2., 4. * iIntensity);\n    vec2 newUV = normCoord * bins;\n    newUV = abs(mod(newUV + 1.5, 2.) - 1.) - 0.5;\n    fragColor = texture(iInput, newUV + 0.5);\n}\n", 
    "resources/effects/test.glsl": "#property description A green & red circle in the center\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c;\n\n    vec2 normCoord = 2. * (uv - 0.5) * aspectCorrection;\n\n    c = vec4(1.) * (1. - smoothstep(iIntensity - 0.1, iIntensity, length(normCoord)));\n    fragColor = composite(fragColor, c);\n\n    c = texture(iChannel[1], (uv - 0.5) / iIntensity + 0.5);\n    c *= 1. - smoothstep(iIntensity - 0.2, iIntensity - 0.1, length(normCoord));\n    fragColor = composite(fragColor, c);\n\n}\n#buffershader\nvoid main(void) {\n    vec2 normCoord = 2. * (uv - 0.5) * aspectCorrection;\n    fragColor = vec4(abs(normCoord), 0., 1.);\n}\n\n#buffershader\nvoid main(void) {\n    vec2 normCoord = 2. * (uv - 0.5) * aspectCorrection;\n    fragColor = vec4(abs(normCoord), 0., 1.);\n}\n", 
    "resources/effects/blowout.glsl": "#property description Push colors towards extremes with smoothstep\n\nvoid main(void) {\n    vec4 color = demultiply(texture(iInput, uv));\n\n    float halfWidth = mix(0.5, 0.05, iIntensity);\n    vec3 targetColor = smoothstep(0.5 - halfWidth, 0.5 + halfWidth, color.rgb);\n\n    // Even when halfWidth = 0.5, smoothstep is not the identity\n    // so we mix here to preserve keep the identity\n    color.rgb = mix(color.rgb, targetColor, iIntensity);\n\n    fragColor = premultiply(color);\n}\n", 
    "resources/effects/bounce.glsl": "#property description Zoom in (bounce) to the beat & audio\n\nvoid main(void) {\n    float factor = 1. - 3. * iIntensity * iAudioLevel * sawtooth(iTime, 0.1);\n    factor = clamp(factor, 0.05, 2.);\n\n    fragColor = texture(iInput, (uv - 0.5) * factor + 0.5);\n}\n", 
    "resources/effects/foh.glsl": "#property description First order (expontential) hold to the beat\n\nvoid main(void) {\n    vec4 prev = texture(iChannel[0], uv);\n    vec4 next = texture(iChannel[1], uv);\n\n    fragColor = mix(next, prev, pow(iIntensity, 0.4));\n    fragColor = clamp(fragColor, 0., 1.);\n}\n\n#buffershader\nvoid main(void) {\n    float t = pow(2., round(6. * iIntensity - 4.));\n    if (iIntensity < 0.09 || mod(iTime, t) < 0.1)\n        fragColor = texture(iInput, uv);\n    else\n        fragColor = texture(iChannel[1], uv);\n}\n", 
    "resources/effects/wavy.glsl": "#property description Rectilinear distortion\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2 shift = vec2(0.);\n    shift += cos(M_PI * normCoord) * sin(iTime * vec2(0.1, 0.13));\n    shift += cos(M_PI * normCoord * 2.) * sin(iTime * vec2(0.33, -0.23)) / 2.;\n    shift += cos(M_PI * normCoord * 3.) * sin(iTime * vec2(0.35, -0.53)) / 3.;\n    shift += cos(M_PI * normCoord * 4.) * sin(iTime * vec2(-0.63, -0.20)) / 4.;\n    shift += cos(M_PI * normCoord * 5.) * sin(iTime * vec2(-0.73, 0.44)) / 5.;\n    shift += cos(M_PI * normCoord * 6.) * sin(iTime * vec2(-0.73, 0.74)) / 6.;\n    shift += cos(M_PI * normCoord * 7.) * sin(iTime * vec2(-1.05, -0.52)) / 7.;\n    shift += cos(M_PI * normCoord * 8.) * sin(iTime * vec2(1.45, -1.22)) / 8.;\n\n    shift += sin(M_PI * normCoord * 5.) * sin(iTime * vec2(0.79, -0.47)) / 5.;\n    shift += sin(M_PI * normCoord * 6.) * sin(iTime * vec2(0.33, 0.79)) / 6.;\n    shift += sin(M_PI * normCoord * 7.) * sin(iTime * vec2(1.15, -0.53)) / 7.;\n    shift += sin(M_PI * normCoord * 8.) * sin(iTime * vec2(-1.36, -1.12)) / 8.;\n\n    float amount = 0.1 * iIntensity;\n\n    fragColor = texture(iInput, (normCoord + shift * amount) / aspectCorrection + 0.5);\n}\n", 
    "resources/effects/projector.glsl": "#property description Projector light scattering\n\n#define DEPTH 200\n\nvec4 lookup(vec2 coord) {\n    vec2 texUV = coord / aspectCorrection + 0.5;\n    return texture(iInput, texUV) * box(texUV);\n}\n\nvoid main() {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec4 col = lookup(normCoord);\n    vec2 source = vec2(0., -0.45);\n    float w = 0.3 * iIntensity;\n    for( int i=0; i<DEPTH; i++ )\n    {\n        w *= 0.98;\n        vec2 s = (normCoord - source) / (float(i) / float(DEPTH)) + source;\n        vec4 res = lookup(s);\n        res *= max(res.r, max(res.g, res.b));\n        res *= w;\n        col = composite(col, res);\n    }\n\n\tfragColor = col;\n}\n", 
    "resources/effects/threedee.glsl": "#property description Fake 3D-glasses effect\n\nvoid main(void) {\n    vec4 baseImage = texture(iInput, uv);\n    float sep = iIntensity * ((baseImage.r + baseImage.g + baseImage.b) * 0.2 + 0.4) * 0.1;\n    sep *= mix(0.3, 1.0, iAudioMid);\n\n    vec4 redImage = texture(iInput, uv + vec2(sep, 0.));\n    vec4 blueImage = texture(iInput, uv - vec2(sep, 0.));\n\n    fragColor.r = mix(baseImage.r, redImage.r / redImage.a * baseImage.a, 0.9);\n    fragColor.g = mix(baseImage.g, blueImage.g / blueImage.a * baseImage.a, 0.3);\n    fragColor.b = mix(baseImage.b, blueImage.b / blueImage.a * baseImage.a, 0.6);\n    fragColor.a = baseImage.a;\n}\n", 
    "resources/effects/depolar.glsl": "#property description Convert rings to vertical lines\n\nvoid main(void) {\n    float angle  = uv.y * M_PI * 1.0;\n    float lengthFactor = 1.0; // sqrt(2.);\n    vec2 rtheta = uv.x * lengthFactor * vec2(sin(angle), -cos(angle));\n    rtheta /= aspectCorrection;\n    rtheta = (rtheta + 1.) / 2.;\n\n    vec2 uv2 = mix(uv, rtheta, iIntensity);\n\n    fragColor = texture(iInput, uv2);\n}\n", 
    "resources/effects/greenaway.glsl": "#property description Shift colors away from green (green is not a creative color)\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec3 hsv = rgb2hsv(fragColor.rgb);\n    float h = hsv.x;\n    h = mod(h + 4. / 6., 1.0) - 3. / 6.;\n    h *= (1. - iIntensity / 3.);\n    h = mod(h - 1. / 6., 1.0);\n    hsv.x = h;\n    fragColor.rgb = hsv2rgb(hsv);\n}\n", 
    "resources/effects/cylinder.glsl": "#property description Wrap the parent texture on a spinning cylinder\n\nvoid main(void) {\n    float angle = iIntensityIntegral * 8.0;\n    angle += 2. * asin(2. * (uv.x - 0.5));\n\n    float x = mod(angle / (M_PI), 2.0);\n    x -= 1.0;\n    x = abs(x);\n\n    vec2 new_uv = vec2(x, uv.y);\n    new_uv = mix(uv, new_uv, smoothstep(0., 0.15, iIntensity));\n    fragColor = texture(iInput, new_uv);\n}\n", 
    "resources/effects/yuvchansep.glsl": "#property description YUV color channel separation\n\nvoid main(void) {\n    float spin = iTime * 0.2;\n    float separate = iIntensity * 0.1 * cos(iTime * M_PI * 0.25);\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    vec2 yOffset = normCoord - separate * vec2(cos(spin), sin(spin));\n    vec2 uOffset = normCoord - separate * vec2(cos(2. + spin), sin(2. + spin));\n    vec2 vOffset = normCoord - separate * vec2(cos(4. + spin), sin(4. + spin));\n\n    vec4 yImage = texture2D(iInput, yOffset / aspectCorrection + 0.5);\n    vec4 uImage = texture2D(iInput, uOffset / aspectCorrection + 0.5);\n    vec4 vImage = texture2D(iInput, vOffset / aspectCorrection + 0.5);\n\n    vec3 yuv = vec3(0.);\n    yuv.r = rgb2yuv(demultiply(yImage).rgb).r;\n    yuv.g = rgb2yuv(demultiply(uImage).rgb).g;\n    yuv.b = rgb2yuv(demultiply(vImage).rgb).b;\n\n    // hmmm alpha is hard #TODO\n    //vec3 rgb = vec3(yImage.r, uImage.g, vImage.b);\n    //float a_out = 1. - (1. - rgb.r) * (1. - rgb.g) * (1. - rgb.b);\n    \n    vec3 rgb = yuv2rgb(yuv);\n    //float a_out = 1. - (1. - rgb.r) * (1. - rgb.g) * (1. - rgb.b);\n    float a_out = yImage.a;\n\n    gl_FragColor = premultiply(vec4(rgb, a_out));\n}\n", 
    "resources/effects/crack.glsl": "#property description And the cracks begin to show\n\n#define MAX_CRACKS 15\nvoid main(void) {\n    // Number of cracks dependent on intensity\n    int numCracks = int(iIntensity * float(MAX_CRACKS));\n\n    // Timebase for time-dependent cracking\n    float t = iTime * 0.5;\n\n    // Amount to perturb the input\n    vec2 perturb = vec2(0.);\n\n    // Becomes 1 when we are close to a crack line\n    float line = 0.;\n\n    for (int i=0; i<MAX_CRACKS; i++) {\n        if (i >= numCracks)\n            break;\n\n        // Store a vec4 of parameters for each crack\n        // .xy is the center point\n        // .zw is the direction vector\n        vec4 crackParameters = texture(iNoise, vec2(float(i) + floor(t)) * onePixel * aspectCorrection);\n        crackParameters.zw = crackParameters.zw - 0.5;\n        crackParameters.zw /= length(crackParameters.zw);\n\n        // Find the vector normal to the crack\n        vec2 normalVector = crackParameters.wz * vec2(-1., 1.);\n\n        // Find which side of the crack we are on\n        float side = dot(uv - crackParameters.xy, normalVector);\n\n        // Perturb the input towards the crack\n        // (as if a mirror were shattered by hitting it)\n        float perturbAmt = step(side, 0.) - 0.5;\n        vec2 perturbDir = normalVector;\n        perturb += perturbDir * perturbAmt;\n\n        // If the dot product is close to zero, we are on the crack line\n        line += 1. - smoothstep(0., onePixel, abs(side));\n    }\n    line = min(line, 1.);\n\n    // Don't perturb off the edges\n    perturb *= 1. - 2. * abs(uv - 0.5);\n\n    // Perturb to the beat\n    //perturb *= sawtooth(t, 0.01);\n\n    // Perturb proprtional to intensity, but not on crack lines\n    fragColor = texture(iInput, uv - perturb * 0.1 * (1.2 - iIntensity) * (1. - line));\n}\n", 
    "resources/effects/halftone.glsl": "#property description CMYK halftoning, like a printer\n\nvec4 rgb2cmyk(vec3 rgb) {\n    vec4 cmyk;\n    cmyk.w = 1. - max(max(rgb.r, rgb.g), rgb.b);\n    cmyk.xyz = (1. - rgb - cmyk.w) / max(1. - cmyk.w, 0.001);\n    return cmyk;\n}\n\nvec3 cmyk2rgb(vec4 cmyk) {\n    return (1. - cmyk.xyz) * (1. - cmyk.w);\n}\n\nvec3 grid(mat2 basis, vec4 cmykMask, vec2 offset) {\n    float points = 300. * pow(2., -9. * iIntensity) + 5.;\n    float r = 0.5 / points;\n\n    mat2 invBasis = inverse(basis);\n\n    vec2 pt = (uv - 0.5) * aspectCorrection;\n\n    vec2 newCoord = round(pt * points * invBasis - offset) + offset;\n    vec2 colorCoord = newCoord / points * basis;\n    vec3 c = texture(iInput, colorCoord / aspectCorrection + 0.5).rgb;\n    vec4 cmyk = rgb2cmyk(c);\n    cmyk *= cmykMask;\n    float cmykValue = dot(cmyk, vec4(1.));\n    r *= sqrt(cmykValue);\n    cmyk /= max(cmykValue, 0.001);\n    c = mix(vec3(1.), cmyk2rgb(cmyk), 1. - smoothstep(r * 0.8, r, length(pt - colorCoord)));\n    return c;\n}\n\nmat2 basis(float t) {\n    t = t * M_PI / 180.;\n    return mat2(cos(t), sin(t),\n                -sin(t), cos(t));\n}\n\nvoid main(void) {\n    mat2 b1 = basis(15.);\n    mat2 b2 = basis(75.);\n    mat2 b3 = basis(0.);\n    mat2 b4 = basis(45.);\n\n    vec3 c1 = grid(b1, vec4(1., 0., 0., 0.), vec2(0.));\n    vec3 m1 = grid(b2, vec4(0., 1., 0., 0.), vec2(0.));\n    vec3 y1 = grid(b3, vec4(0., 0., 1., 0.), vec2(0.));\n    vec3 k1 = grid(b4, vec4(0., 0., 0., 1.), vec2(0.));\n    vec3 c2 = grid(b1, vec4(1., 0., 0., 0.), vec2(0.5));\n    vec3 m2 = grid(b2, vec4(0., 1., 0., 0.), vec2(0.5));\n    vec3 y2 = grid(b3, vec4(0., 0., 1., 0.), vec2(0.5));\n    vec3 k2 = grid(b4, vec4(0., 0., 0., 1.), vec2(0.5));\n    vec3 total = vec3(1.);\n    total = min(total, c1);\n    total = min(total, m1);\n    total = min(total, y1);\n    total = min(total, k1);\n    total = min(total, c2);\n    total = min(total, m2);\n    total = min(total, y2);\n    total = min(total, k2);\n    vec4 final = vec4(total, 1.);\n\n    fragColor = texture(iInput, uv);\n    final.a = max(fragColor.a, max(total.r, max(total.g, total.b)));\n    fragColor = mix(fragColor, final, smoothstep(0., 0.1, iIntensity));\n}\n", 
    "resources/effects/snowcrash.glsl": "#property description Snowcrash: white static noise\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    float x = rand(vec3(gl_FragCoord.xy, iTime));\n    vec4 c = vec4(x, x, x, 1.0);\n    fragColor = mix(fragColor, c, iIntensity);\n}\n", 
    "resources/effects/pink.glsl": "#property description Pink polka dots\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c;\n\n    float r = 0.2;\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    c = vec4(1., 0.5, 0.5, 1.0);\n    c *= 1. - smoothstep(r - onePixel, r, length(mod(normCoord * 5. * iIntensity - 0.5, 1.) - 0.5));\n    c *= smoothstep(0., 0.1, iIntensity);\n    fragColor = composite(fragColor, c);\n}\n", 
    "resources/effects/rolling.glsl": "#property description Rolling shutter effect\n\nvoid main(void) {\n    float rate = 4.;\n    float yv = 1.0 - mod(iTime, rate) / rate;\n    vec4 old = texture(iChannel[0], uv);\n    vec4 new = texture(iInput, uv);\n    float dist = abs(uv.y - yv); // TODO: make this wrap around\n    fragColor = mix(old, new, max(0., 1.0 - iFPS * 0.2 * dist));\n    fragColor = mix(new, fragColor, pow(iIntensity, 0.1));\n}\n", 
    "resources/effects/csmooth.glsl": "#property description Apply gaussian spatial blur\nfloat squared(float x) { return x * x;}\nfloat gaussian(float x)\n{\n    return exp(-0.5*x*x);\n}\n\nvoid main()\n{\n    float sigma = iIntensity / 32.;\n    vec4 acc = vec4(0.,0.,0.,0.);\n    float norm = 0.;\n    float stp = aspectCorrection.y * sigma;\n    for(float i = -2.; i <= 2.; i+=(1./16.)) {\n        float off = i * stp;\n        float k = gaussian(i);\n        norm += k;\n        vec2 pt = clamp(vec2(uv.x,uv.y + off),0.,1.);\n        acc += k * texture(iChannel[1],pt);\n    }\n    fragColor = acc / norm;\n}\n#buffershader\nfloat squared(float x) { return x * x;}\nfloat gaussian(float x)\n{\n    return exp(-0.5*x*x);\n}\n\nvoid main()\n{\n    float sigma = iIntensity / 32.;\n    vec4 acc = vec4(0.,0.,0.,0);\n    float norm = 0.;\n    float stp = aspectCorrection.x * sigma;\n    for(float i = -2.; i <= 2.; i+=(1./16.)) {\n        float off = i * stp;\n        vec2 pt = clamp(vec2(uv.x + off,uv.y),0.,1.);\n        float k = gaussian(i);\n        norm += k;\n        acc += k * texture(iInputs[0],pt);\n    }\n    fragColor = acc / norm;\n}\n\n", 
    "resources/effects/polar.glsl": "#property description Convert vertical lines to rings\n\nvoid main(void) {\n    vec2 normCoord = 2. * (uv - 0.5) * aspectCorrection;\n\n    //float lengthFactor = sqrt(2.);\n    float lengthFactor = 1.0;\n\n    vec2 newUV = vec2(length(normCoord) / lengthFactor, abs(atan(normCoord.x, -normCoord.y) / M_PI)) - 0.5;\n    newUV = newUV / aspectCorrection + 0.5;\n\n    fragColor = texture(iInput, mix(uv, newUV, iIntensity));\n}\n", 
    "resources/effects/heart.glsl": "#property description Pink heart\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n\n    // heart from shadertoy\n    vec2 normCoord = (uv - 0.5) * aspectCorrection + vec2(0., -0.15);\n    normCoord *= 2. / iIntensity;\n    float a = atan(normCoord.x, normCoord.y) / M_PI;\n    float r = length(normCoord);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n    vec4 c = vec4(1., 0.5, 0.5, 1. - smoothstep(0., 3. * onePixel, r - d));\n    fragColor = composite(fragColor, premultiply(c));\n}\n", 
    "resources/effects/chansep.glsl": "#property description Red / green / blue color channel separation\n// AKA \"Chromatic Aberration\"\n\nvoid main(void) {\n    float spin = iTime * 0.2;\n    float separate = iIntensity * 0.1 * cos(iTime * M_PI * 0.25);\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2 redOffset = normCoord - separate * vec2(cos(spin), sin(spin));\n    vec2 greenOffset = normCoord - separate * vec2(cos(2. + spin), sin(2. + spin));\n    vec2 blueOffset = normCoord - separate * vec2(cos(4. + spin), sin(4. + spin));\n\n    vec4 redImage = texture(iInput, redOffset / aspectCorrection + 0.5);\n    vec4 greenImage = texture(iInput, greenOffset / aspectCorrection + 0.5);\n    vec4 blueImage = texture(iInput, blueOffset / aspectCorrection + 0.5);\n\n    vec3 rgb = vec3(redImage.r, greenImage.g, blueImage.b);\n    float a_out = 1. - (1. - rgb.r) * (1. - rgb.g) * (1. - rgb.b);\n    fragColor = vec4(rgb, a_out);\n}\n", 
    "resources/effects/distort.glsl": "#property description Distort the screen to the beat\n\nvoid main(void) {\n    vec3 noise_input = vec3(uv, iTime * 0.3);\n    vec2 shift = (vec2(noise(noise_input), noise(noise_input + 100.)) - 0.5);\n    shift += (vec2(noise(2. * noise_input), noise(2. * noise_input + 100.)) - 0.5) * 0.5;\n    shift += (vec2(noise(4. * noise_input), noise(4. * noise_input + 100.)) - 0.5) * 0.25;\n    shift = 0.3 * shift;\n    shift /= aspectCorrection;\n\n    fragColor = texture(iInput, uv + shift * iIntensity * (15. * iAudioLevel) * sawtooth(iTime, 0.1));\n}\n", 
    "resources/effects/zoh.glsl": "#property description Zero order hold to the beat\n\nvoid main(void) {\n    vec4 prev = texture(iChannel[0], uv);\n    vec4 next = texture(iInput, uv);\n\n    float t = pow(2., round(6. * iIntensity - 4.));\n    float a = 1.;\n\n    if (iIntensity < 0.09)\n        a = 0.;\n    else if (mod(iTime, t) < 0.1)\n        a = 0.;\n\n    fragColor = mix(next, prev, a);\n}\n", 
    "resources/effects/lpf.glsl": "#property description Smooth output\n\nvoid main(void) {\n    vec4 prev = texture(iChannel[0], uv);\n    vec4 next = texture(iInput, uv);\n    fragColor = mix(next, prev, pow(iIntensity, 0.4));\n}\n", 
    "resources/effects/deblack.glsl": "#property description Increase alpha ( undo \"black\" )\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    float a = (1. - iIntensity);\n    a = max(a, fragColor.a);\n    fragColor /= a;\n}\n", 
    "resources/effects/zoomout.glsl": "#property description Zoom out\n\nvoid main(void) {\n    float factor = mix(1.0, 8.0, pow(iIntensity, 4.0));\n    vec2 newUv = (uv - 0.5) * factor + 0.5;\n    fragColor = texture(iInput, newUv);\n\n    // If the coordinate is outside the box, make set the color to transparent\n    vec2 s = step(vec2(0., 0.), newUv) - step(vec2(1., 1.), newUv);\n    fragColor *= s.x * s.y;\n}\n", 
    "resources/effects/qlpf.glsl": "#property description Smooth output (quadratic LPF)\n\nvoid main(void) {\n    vec4 prev = texture(iChannel[0], uv);\n    vec4 next = texture(iInput, uv);\n    float d = distance(prev, next) / 2.0;\n    float k = pow(iIntensity, 0.3) * (1.0 - pow(d, mix(2.5, 1.0, iIntensity)));\n    fragColor = mix(next, prev, k);\n}\n", 
    "resources/effects/purple.glsl": "#property description Organic purple waves\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    //mat2 rot = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n    vec4 c;\n\n    normCoord += 0.5;\n    float y = pow(sin(cos(iTime / 4.) * normCoord.y * 8. + normCoord.x), 2.);\n    float x = mod(sin(normCoord.x * 4.) + cos(normCoord.y * normCoord.x * 5.) * (y * 0.2 + 0.8) + 3.0, 1.0);\n\n    c.r = mix(x, y, 0.3);\n    c.b = pow(mix(x, y, 0.7), 0.6);\n    c.g = 0.;\n    c.a = 1.;\n    c *= iIntensity;\n\n    fragColor = composite(texture(iInput, uv), c);\n}\n", 
    "resources/effects/diodelpf.glsl": "#property description Apply smoothing over time with new hits happening instantly\n\nvoid main(void) {\n    vec4 prev = texture(iChannel[0], uv);\n    vec4 next = texture(iInput, uv);\n    fragColor.rgb = next.rgb;\n    if (next.a > prev.a) {\n        fragColor = next;\n    } else {\n        prev *= pow(iIntensity, 0.1);\n        fragColor = composite(next, prev);\n    }\n    fragColor.a = clamp(fragColor.a, 0., 1.);\n    \n}\n", 
    "resources/effects/rekt.glsl": "#property description Get (covered in random) rekt(angles)\n\nvoid main(void) {\n    vec4 under = texture(iInput, uv);\n\n    vec4 over = texture(iChannel[1], uv);\n    over.a = step(0.001, over.a);\n    over.a *= smoothstep(0., 0.2, iIntensity);\n    over.rgb *= over.a;\n\n    fragColor = composite(under, over);\n}\n\n#buffershader\n\nvoid main(void) {\n    vec4 before = texture(iChannel[1], uv);\n    before.a = max(before.a - 0.01, 0.);\n\n    vec2 xy = vec2(rand(vec2(iTime, 0.)), rand(vec2(iTime, 1.)));\n    vec2 wh = vec2(rand(vec2(iTime, 2.)), rand(vec2(iTime, 3.))) * 0.3 + 0.1;\n    vec4 color = vec4(rand(vec2(iTime, 4.)), rand(vec2(iTime, 5.)), rand(vec2(iTime, 6.)), 1.0);\n\n    float inside = box((uv - xy) / wh + 0.5);\n    fragColor = mix(before, color, inside);\n}\n", 
    "resources/effects/interstellar.glsl": "#property description Lightspeed travel rays\n#property author https://www.shadertoy.com/view/Xdl3D2\n\nconst float tau = 6.28318530717958647692;\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\nvec4 Noise( in ivec2 x )\n{\n\treturn 2. * texture(iNoise, (vec2(x)+0.5)/256.0, -100.);\n}\n\nvoid main()\n{\n\tvec3 ray;\n\tray.xy = 2.0*(gl_FragCoord.xy-iResolution.xy*.5)/iResolution.x;\n\tray.z = 1.0;\n\n\t//float offset = iTime*.5;\n\t//float speed2 = (cos(offset)+1.0)*2.0;\n\tfloat offset = iIntensityIntegral * 0.5;\n\tfloat speed2 = 3. * iAudioLow;\n\tfloat speed = speed2+.1;\n\t//offset += sin(offset)*.96;\n\t//offset *= 2.0;\n\n\n\tvec3 col = vec3(0);\n\n\tvec3 stp = ray/max(abs(ray.x),abs(ray.y));\n\n\tvec3 pos = 2.0*stp+.5;\n\tfor ( int i=0; i < 20; i++ )\n\t{\n\t\tfloat z = Noise(ivec2(pos.xy)).x;\n\t\tz = fract(z-offset);\n\t\tfloat d = 50.0*z-pos.z;\n\t\tfloat w = pow(max(0.0,1.0-8.0*length(fract(pos.xy)-.5)),2.0);\n\t\tvec3 c = max(vec3(0),vec3(1.0-abs(d+speed2*.5)/speed,1.0-abs(d)/speed,1.0-abs(d-speed2*.5)/speed));\n\t\tcol += 1.5*(1.0-z)*c*w;\n\t\tpos += stp;\n\t}\n\n\tvec4 fc;\n    fc.rgb = ToGamma(col);\n    fc.a = max(max(fc.r, fc.g), fc.b);\n    fc *= smoothstep(0., 0.2, iIntensity);\n\n    vec4 c = texture(iInput, uv);\n    fragColor = composite(c, fc);\n}\n", 
    "resources/effects/smoke.glsl": "#property description Perlin noise green smoke\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    vec3 noise_input = vec3(normCoord * iIntensity * 4., iIntensity + iIntensityIntegral * 0.1);\n    float n = noise(noise_input) - 0.1;\n    n += (noise(2. * noise_input) - 0.5) * 0.5;\n    n += (noise(4. * noise_input) - 0.5) * 0.25;\n    n += (noise(8. * noise_input) - 0.5) * 0.125;\n    n += (noise(16. * noise_input) - 0.5) * 0.0625;\n    n = n / 3.;\n\n    float a = clamp(n * n * 5., 0., 1.) * smoothstep(0., 0.2, iIntensity);\n\n    fragColor = texture(iInput, uv);\n    fragColor = composite(fragColor, vec4(0., a, 0., a));\n}\n", 
    "resources/effects/kaleidoscope.glsl": "#property description Mirror and repeat the pattern in a circle\n\nvoid main(void) {\n    vec2 normCoord = 2. * (uv - 0.5);\n    normCoord *= aspectCorrection;\n    float r = length(normCoord);\n    float theta = atan(normCoord.y, normCoord.x);\n\n    float bins = iIntensity * 5. + 2.;\n    float tStep = M_PI / bins;\n    theta = abs(mod(theta + tStep, 2. * tStep) - tStep);\n\n    vec2 newUV = r * vec2(cos(theta), sin(theta));\n    newUV *= 0.707;\n    newUV /= aspectCorrection;\n    newUV = newUV * 0.5 + 0.5;\n\n    fragColor = texture(iInput, mix(uv, newUV, smoothstep(0., 0.2, iIntensity)));\n}\n", 
    "resources/effects/uvmapself.glsl": "#property description Apply `uvmap` using 1 input for both UV & RGB\n\nvoid main(void) {\n    vec4 map = texture(iInput, uv);\n    vec2 newUV = mix(uv, map.rg, iIntensity * map.a);\n    fragColor = texture(iInput, newUV);\n}\n", 
    "resources/effects/lorenz.glsl": "#property description Lorenz attractor\n\nvec3 lorenz(vec3 xyz, vec3 srb) {\n    // Compute the derivative of the Lorenz system at point `xyz` given parameters `srb`\n    // srb.xyz --> sigma, rho, beta\n    // https://en.wikipedia.org/wiki/Lorenz_system\n\n    return vec3(\n        srb.x * (xyz.y - xyz.x),\n        xyz.x * (srb.y - xyz.z) - xyz.y,\n        xyz.x * xyz.y - srb.z * xyz.z);\n}\n\nvoid main(void) {\n    // Classic Lorenz curve parameters\n    vec3 srb = vec3(10., 28., 8. / 3.); // sigma, rho, beta paramaters\n\n    // Initial coordinate\n    vec3 xyz = vec3(uv - 0.5, sin(iTime));\n    xyz *= mix(vec3(1.), vec3(90., 120., 20), smoothstep(0., 0.7, iIntensity));\n    xyz += vec3(10., 0., 30.);\n\n    #define N_STEPS 20\n    #define STEP_SIZE 0.01\n    #define MAGIC_SCALE 0.01 // function of other 2 values... somehow\n    vec3 start = xyz;\n    for (int i = 0; i < N_STEPS; i++) {\n        // Rough Euler's method\n        xyz += lorenz(xyz, srb) * STEP_SIZE;\n    }\n\n    // How much did wwe move?\n    vec3 dxyz = (xyz - start);\n    vec2 duv = (dxyz.xy + 0.5 * dxyz.z) * MAGIC_SCALE;\n\n    // Distort along contour\n    vec2 newUV = uv + duv * iIntensity;\n    fragColor = texture(iInput, newUV) * box(newUV);\n}\n", 
    "resources/effects/triangulate.glsl": "#property description \"Pixelate\" the output into triangles\n\nvoid main(void) {\n    vec3 normCoord = vec3(0.0);\n    normCoord.xy = (uv - 0.5) * aspectCorrection;\n    normCoord.z = normCoord.x + normCoord.y;\n\n    float bs = 256. * pow(2., -9. * iIntensity);\n    vec3 bins = vec3(0.0);\n    //bins.xy = bs * aspectCorrection;\n    bins.xy = vec2(bs);\n    bins.z = bins.y;\n    //bins.y += bins.x;\n\n    //normCoord.xy = round(normCoord.xy * bins.xy) / bins.xy;\n    normCoord = round(normCoord * bins) / bins;\n    //normCoord.z = (mod(floor(normCoord.z * bins.z), 2.0) - 1.0) / (bins.z * 2);\n\n    //normCoord.y -= normCoord.x;\n    //normCoord.y -= normCoord.z;\n    normCoord.y = mix(normCoord.y, normCoord.z, 0.5);\n\n    vec2 newUV = normCoord.xy / aspectCorrection + 0.5;\n    newUV = mix(uv, newUV, smoothstep(0., 0.1, iIntensity));\n\n    //fragColor = texture(iInput, newUV);\n    fragColor.rgba = vec4(1.0);\n    fragColor.rg = newUV.rr;\n}\n", 
    "resources/effects/dwwave.glsl": "#property description Diagonal white wave\n\nvoid main(void) {\n    float xpos = iIntensityIntegral * 1.5;\n    float xfreq = (iIntensity + 0.5) * 2.;\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float x = mod((normCoord.x + normCoord.y) * 0.5 * xfreq + xpos, 1.);\n    fragColor = texture(iInput, uv);\n    vec4 c = vec4(1.) * step(x, 0.3) * smoothstep(0., 0.5, iIntensity);\n    fragColor = composite(fragColor, c);\n}\n", 
    "resources/effects/warble.glsl": "#property description Makes the image warbly\n\nvoid main(void) {\n    vec2 newPt = (uv - 0.5) * aspectCorrection;\n\n    float bins = max(iIntensity * 10., 1.);\n\n    vec2 newPtInt = floor(newPt * bins);\n    vec2 newPtFrac = fract(newPt * bins);\n    newPtFrac = newPtFrac * 2. - 1.;\n\n    vec2 displacement = pow(abs(newPtFrac), vec2(1. + 2. * iIntensity)) * sign(newPtFrac);\n    newPt = (newPtInt + 0.5 * displacement + 0.5) / bins;\n\n    fragColor = texture(iInput, newPt / aspectCorrection + 0.5);\n}\n", 
    "resources/effects/yuvsat.glsl": "#property description Saturate colors in YUV space by making things more UV\n\nvoid main(void) {\n    vec4 c = demultiply(texture(iInput, uv));\n    c.rgb = rgb2yuv(c.rgb);\n\n    vec2 d = c.gb - vec2(0.5, 0.5);\n    c.gb += d * iIntensity * 3.0;\n\n    c.gb = clamp(c.gb, 0., 1.);\n    c.rgb = yuv2rgb(c.rgb);\n    fragColor = premultiply(c);\n}\n", 
    "resources/effects/flower.glsl": "#property description Convert vertical lines to radial flower pattern\n\nvoid main(void) {\n    float n_sides = (iIntensity * 7.) + 2.5;\n    float whole_sides = 0.;\n    n_sides = modf(n_sides, whole_sides);\n    n_sides = whole_sides + smoothstep(0.2, 0.8, n_sides);\n\n    vec2 xy_cent = 2. * uv - 1.;\n    float angle = atan(xy_cent.y, xy_cent.x);\n    float arc = 2. * M_PI / n_sides;\n    float a1 = mod(angle, arc);\n    //float lengthFactor = sqrt(2.);\n    float lengthFactor = 1.0;\n    float corr = 1. / (pow(cos(a1 - arc / 2.), 2.) * lengthFactor * cos(arc / 2.));\n\n    vec2 rtheta = vec2(length(xy_cent) * corr, 0.5 + angle / (2. * M_PI));\n    vec2 uv2 = mix(uv, rtheta, smoothstep(0., 0.2, iIntensity));\n\n    fragColor = texture(iInput, uv2) * box(uv2);\n}\n", 
    "resources/effects/rsheen.glsl": "#property description Cycle quickly through the rainbow according to lightness, giving things a rainbow sheen\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec3 hsv = rgb2hsv(fragColor.rgb);\n    float newHue = mod(hsv.x + hsv.z * iIntensity * 30. * (1. - hsv.z), 1.);\n    hsv.x = newHue;\n    fragColor.rgb = hsv2rgb(hsv);\n}\n", 
    "resources/effects/vignette.glsl": "#property description Applies vignette\n\nfloat hyper_length(vec2 c, float f) {\n    return pow(abs(pow(c.x, f)) + abs(pow(c.y, f)), 1. / f);\n}\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec2 coord = (uv - 0.5);\n\n    float f = 3. / iIntensity;\n    float edge1 = 2. * hyper_length(coord, f);\n    float edge2 = 0.5 * length(coord / max(abs(coord.x), abs(coord.y)));\n\n    fragColor *= 1. - smoothstep(1. - 0.5 * iIntensity, 1., edge1);\n}\n", 
    "resources/effects/smooth.glsl": "#property description Apply gaussian resampling ( at pixel aligned points )\nfloat squared(float x) { return x * x;}\nfloat gaussian(float x, float sigma)\n{\n    return ((sigma!=0.) ? exp(-0.5*squared(x/sigma)) : ((x==0.) ? 1.0 : 0.0));\n}\n\nvoid main()\n{\n    float sigma = iIntensity * 16.;\n    vec4 acc = vec4(0.,0.,0.,0);\n    float norm = 0.;\n    float stp = 1./iResolution.y;\n    for(float i = -16.; i <= 16.; i+=1.) {\n        float off =i * stp;\n        vec2 pt = clamp(vec2(uv.x,uv.y + off),0.,1.);\n\n        float k = gaussian(i,sigma);\n        norm += k;\n        acc += k * texture(iChannel[1],pt);\n    }\n    fragColor = acc / norm;\n}\n#buffershader\nfloat squared(float x) { return x * x;}\nfloat gaussian(float x, float sigma)\n{\n    return ((sigma!=0.) ? exp(-0.5*squared(x/sigma)) : ((x==0.) ? 1.0 : 0.0));\n}\n\nvoid main()\n{\n    float sigma = iIntensity * 16.;\n    vec4 acc = vec4(0.,0.,0.,0);\n    float norm = 0.;\n    float stp = 1./iResolution.x;\n    for(float i = -16.; i <= 16.; i+=1.) {\n        float off = stp * i;\n        vec2 pt = clamp(vec2(uv.x + off,uv.y),0.,1.);\n        float k = gaussian(i,sigma);\n        norm += k;\n        acc += k * texture(iInputs[0],pt);\n    }\n    fragColor = acc / norm;\n}\n", 
    "resources/effects/attractor.glsl": "#property description Flow the first image around the second using lightness gradient\n#property inputCount 2\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c = texture(iChannel[1], uv);\n    c *= smoothstep(0., 0.2, iIntensity);\n    fragColor = composite(fragColor, c);\n}\n\n#buffershader\n\nvec2 getGradient() {\n    vec2 EPSILON = vec2(0.01);\n\n    vec4 val = texture(iInputs[1], uv);\n\n    // Take a small step in X\n    vec4 dcdx = (texture(iInputs[1], uv + vec2(EPSILON.x, 0.)) - val) / EPSILON.x;\n\n    // Take a small step in Y\n    vec4 dcdy = (texture(iInputs[1], uv + vec2(0., EPSILON.y)) - val) / EPSILON.y;\n\n    vec2 dc = vec2(dot(dcdx.rgb, vec3(1.)), dot(dcdy.rgb, vec3(1.)));\n\n    dc = clamp(0.008 * dc, -1., 1.);\n\n    return dc;\n}\n\nvoid main(void) {\n    vec4 c1 = texture(iInputs[0], uv);\n\n    // Perturb according to gradient\n    vec2 perturb = -getGradient(); // Avoid dark\n    vec4 c2 = texture(iChannel[1], uv + 0.05 * iIntensity * perturb);\n\n    // Blend between the current frame and a slightly shifted down version of it using the max function\n    fragColor = max(c1, c2);\n\n    // Fade out slowly\n    float fadeAmount = 0.01 + 0.2 * (1. - iIntensity);\n    fragColor = max(fragColor - fadeAmount, vec4(0.));\n\n    // Clear back buffer when intensity is low\n    fragColor *= smoothstep(0., 0.1, iIntensity);\n}\n", 
    "resources/effects/speckle.glsl": "#property description Per-pixel twinkle effect\n\nvoid main(void) {\n    fragColor = texture(iChannel[0], uv);\n    fragColor *= exp(-iIntensity / 20.);\n    if (rand(vec3(uv, iTime)) < exp(-iIntensity * 4.)) {\n        fragColor = texture(iInput, uv);\n    }\n}\n", 
    "resources/effects/spin.glsl": "#property description Rotate the screen\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float r = iIntensityIntegral * 0.6;\n    float s = sin(r * M_PI);\n    float c = cos(r * M_PI);\n    mat2 rot = mat2(c, -s, s, c);\n\n    vec2 newUV = normCoord * rot / aspectCorrection;\n    //newUV *= min(iResolution.x, iResolution.y) / max(iResolution.x, iResolution.y) * sqrt(0.5);\n    newUV += 0.5;\n\n    vec4 oc = texture(iInput, uv);\n    vec4 nc = texture(iInput, newUV) * box(newUV);\n\n    fragColor = mix(oc, nc, smoothstep(0., 0.2, iIntensity));\n}\n", 
    "resources/effects/yuvmapd.glsl": "#property description Use UV (from YUV) as delta-.uv and crossfade\n\n#property inputCount 2\nvoid main(void) {\n    vec4 map = texture(iInputs[1], uv);\n    vec3 yuv = rgb2yuv(demultiply(map).rgb);\n    vec2 scaledUV = (yuv.gb - 0.5) * 4.0;\n    vec2 newUV = uv + scaledUV * min(iIntensity * 2.0, 1.0) * map.a;\n    newUV = clamp(newUV, 0., 1.);\n    vec4 mappedColor = texture(iInput, newUV);\n    fragColor = mix(mappedColor, map, max(0.0, iIntensity * 2.0 - 1.0));\n}\n", 
    "resources/effects/glitch.glsl": "#property description Digital glitching\n\nvoid main(void) {\n    vec4 c = texture(iInputs[0], uv);\n\n    const int N_PARTITIONS = 3;\n    const vec2 blockSizes[N_PARTITIONS] = vec2[](vec2(0.3, 0.5), vec2(1., 0.15), vec2(1., 1.));\n\n    // Partition image into blocks a few different ways\n    vec4 n1 = vec4(1.);\n    vec4 n2 = vec4(1.);\n    for (int i=0; i<N_PARTITIONS; i++) {\n        vec2 block = floor(uv / blockSizes[i]) * blockSizes[i];\n        vec4 t1 = texture(iNoise, vec2(iTime / 1000., (3.1 * block.x) + (7.8 * block.y)));\n        n1 *= t1;\n        vec4 t2 = texture(iNoise, vec2(iTime / 1000., (6.7 * block.x) + (2.9 * block.y)));\n        n2 *= t2;\n    }\n    n1 = pow(n1, vec4(0.1));\n    n2 = pow(n2, vec4(0.1));\n\n    // White noise glitch\n    float noise_glitch = step(1. - 0.2 * iIntensity, n1.x);\n    vec4 white_noise = texture(iNoise, uv + iTime);\n    white_noise.rgb *= white_noise.a;\n    c = mix(c, white_noise, noise_glitch);\n\n    // Invert colors\n    float invert_glitch = step(1. - 0.2 * iIntensity, n1.y);\n    c.rgb = invert_glitch - 2. * (invert_glitch - 0.5) * c.rgb;\n\n    // Solid color glitch\n    float solid_glitch = step(1. - 0.2 * iIntensity, n1.z);\n    c = mix(c, vec4(0., 1., 0., 1.), solid_glitch);\n\n    // Shift glitch\n    float shift_glitch = step(1. - 0.2 * iIntensity, n1.w);\n    c = mix(c, texture(iInputs[0], uv - vec2(0.2, 0.)), shift_glitch);\n\n    // Freeze glitch\n    float freeze_glitch = step(1. - 0.2 * iIntensity, n2.x);\n    c = mix(c, texture(iChannel[0], uv), freeze_glitch);\n\n    fragColor = c;\n}\n", 
    "resources/effects/loopy.glsl": "#property description Loopy laser-like pattern\n\nvoid main(void) {\n    vec4 originalColor = texture(iInput, uv);\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    // Decompose coordinate into R-theta\n    float r = length(normCoord);\n    float angle = atan(normCoord.x, normCoord.y);\n\n    // Compute the size/position of the 'bulge' that travels around the circle\n    float BULGE_SPEED = 1. / 8.0;\n    float BULGE_WIDTH = mix(0.20, 0.28, iAudioLevel);  // 0.25\n    float BULGE_HEIGHT = mix(0.01, 0.035, iIntensity); // 0.03\n    float NOBULGE_HEIGHT = 0.01;\n    float angle_t = mod(angle / M_PI + iTime * BULGE_SPEED, 2.0) - 1.0;\n    float bulge = exp(-pow(angle_t / BULGE_WIDTH, 2.)) * BULGE_HEIGHT;\n    bulge += NOBULGE_HEIGHT;\n\n    // Compute distance from circle, including bulge & standing wave\n    float CIRCLE_R = mix(0.10, 0.40, iIntensity); //0.33\n    float WAVE_COUNT = 16.;\n    float WAVE_SPEED = 1. / 4.0;\n    float d = abs(r - CIRCLE_R - bulge * sin(angle * WAVE_COUNT - iTime * M_PI * WAVE_SPEED));\n\n    // Turn distance into alpha \n    float THICKNESS = mix(0.07, 0.12, iAudioLow); // 0.10\n    float alpha = max(0.0, 1.0 - 10. * d);\n    alpha = max(0., cos(min(1.8, (1.0 - alpha) / THICKNESS)));\n\n    // Composite purple onto input\n    vec4 color = vec4(0.8, 0.1, 0.9, 1.0);\n    color *= alpha;\n    color *= smoothstep(0.0, 0.1, iIntensity);\n    fragColor = composite(originalColor, color);\n}\n", 
    "resources/effects/afixhighlight.glsl": "#property description Brightly highlight pixels in pink where fc.rgb > f.a\n\nvoid main(void) {\n    vec4 c = texture(iInput, uv);\n    float a = max(max(c.r,c.g),c.b);\n\n    vec4 black = vec4(0., 0., 0., 1.);\n    vec4 pink = vec4(1., 0., 1., 1.);\n    vec4 highlight = mix(c, pink, (a <= c.a ? 0. : 1.));\n\n    fragColor = mix(c, highlight, iIntensity);\n}\n", 
    "resources/effects/gay.glsl": "#property description Excessive rainbow\n\n// A radiance classic\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c = vec4(hsv2rgb(vec3(mod(uv.x + iIntensityIntegral, 1.), 1., 1.)), 1.);\n    fragColor = mix(fragColor, c, smoothstep(0., 0.2, iIntensity));\n}\n", 
    "resources/effects/mirror.glsl": "#property description Place a vertical mirror to make the frame symmetric\n\nvoid main(void) {\n    float xPos = (1. - iIntensity) * 0.5 + 0.5;\n    float x = -abs(uv.x - xPos) + xPos;\n    fragColor = texture(iInput, vec2(x, uv.y));\n}\n", 
    "resources/effects/tilt.glsl": "#property description Move input vertically\n\nvoid main()\n{\n    vec2 pt = uv;\n    pt.y = mod(pt.y + iIntensity,1.);\n    fragColor = texture(iInputs[0], pt);\n}\n", 
    "resources/effects/eye.glsl": "#property description Distort effect that makes the image look more like an eye\n\nvoid main(void) {\n    vec2 normCoord = 2. * (uv - 0.5) * aspectCorrection;\n\n    //float lengthFactor = sqrt(2.);\n    float lengthFactor = 1.0;\n\n    float len = length(normCoord) / lengthFactor;\n    float angle = abs(atan(normCoord.x, normCoord.y) / M_PI);\n\n    vec2 newUVCenter = vec2(angle, 2. * len) - 0.5;\n    vec2 newUVMiddle = vec2(2. * len - 1., angle) - 0.5;\n    vec2 newUVOutside = 0.5 * normCoord;\n\n    float a = iIntensity * 0.2; // Make the eye open a little\n    float centerShape = smoothstep(0.1 + a, 0.2 + a, len);\n    float eyeShape = smoothstep(0.9 + a, 1.0 + a, length(abs(normCoord) + vec2(0., 0.7)));\n\n    vec2 newUV = mix(newUVCenter, newUVMiddle, centerShape);\n    newUV = mix(newUV, newUVOutside, eyeShape);\n\n    newUV = newUV / aspectCorrection + 0.5;\n\n    fragColor = texture(iInput, mix(uv, newUV, iIntensity));\n}\n", 
    "resources/effects/uvmapselfn.glsl": "#property description Apply `uvmapself` repeatedly. Instant hellscape\n\n#define N 5\n\nvoid main(void) {\n    // It looks better at low values of intensity\n    float intensity = pow(iIntensity, 3.0);\n\n    vec2 newUV = uv;\n    for (int i = 0; i < N; i++) {\n        vec4 map = texture(iInput, newUV);\n        newUV = mix(newUV, map.rg, intensity * map.a);\n    }\n    fragColor = texture(iInput, newUV);\n}\n", 
    "resources/effects/oscope.glsl": "#property description Fake waveform visualizer that looks like an oscilloscope\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float x = normCoord.x;\n    float wave = 0.;\n    wave += 0.6 * sin(x * 10. + iTime * 1.) * iAudioLow;\n    wave += 0.6 * sin(x * 15. + iTime * -0.3) * iAudioLow;\n    wave += 0.2 * sin(x * 40. + iTime * 8.) * iAudioMid;\n    wave += 0.2 * sin(x * 70. + iTime * -3.) * iAudioLow;\n    wave += 0.1 * sin(x * 120. + iTime * 16.) * iAudioHi;\n    wave += 0.1 * sin(x * 180. + iTime * -10.) * iAudioHi;\n    wave *= iAudioLevel;\n    wave *= smoothstep(0., 0.3, iIntensity);\n\n    float d = abs(normCoord.y - wave);\n\n    float glow = 1. - smoothstep(0., (0.02 + iAudioHi * 0.3) * smoothstep(0., 0.5, iIntensity), d);\n    glow += 0.5 * (1. - smoothstep(0., (0.3 + iAudioHi * 0.3) * iIntensity, d));\n    vec4 c = vec4(0., 1., 0., 1.) * glow;\n    fragColor = composite(fragColor, c);\n}\n\n", 
    "resources/effects/nogreen.glsl": "#property description Zero out the green channel (green is not a creative color)\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    fragColor.g *= 1. - iIntensity;\n}\n", 
    "resources/effects/posterize.glsl": "#property description Reduce number of colors\n\nvoid main(void) {\n    //float bins = 256. * pow(2, -8. * iIntensity);\n    float bins = min(256., 1. / iIntensity);\n    \n    // bin in non-premultiplied space, then re-premultiply\n    vec4 c = demultiply(texture(iInput, uv));\n    c.rgb = round(c.rgb * bins) / bins;\n    c.rgb = clamp(c.rgb, 0.0, 1.0);\n    fragColor = premultiply(c);\n}\n", 
    "resources/effects/shake.glsl": "#property description Shake the image when there are lows\n\nvoid main(void) {\n    float t = iTime * 2. *  M_PI;\n    vec2 sweep = vec2(cos(3. * t), sin(2. * t));\n\n    float amount = iIntensity * 0.3 * max(iAudioLow - 0.2, 0.) * sawtooth(iTime, 0.2);\n\n    vec2 newUV = (uv - 0.5) + sweep * amount + 0.5;\n\n    fragColor = texture(iInput, newUV) * box(newUV);\n}\n", 
    "resources/effects/fire.glsl": "#property description Fire from the bottom\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    vec3 noise_input = vec3(normCoord * 3. + vec2(0., -iTime * 0.5), iTime * 0.3);\n    vec2 shift = (vec2(noise(noise_input), noise(noise_input + 100.)) - 0.5);\n    shift += (vec2(noise(2. * noise_input), noise(2. * noise_input + 100.)) - 0.5) * 0.5;\n    shift += (vec2(noise(4. * noise_input), noise(4. * noise_input + 100.)) - 0.5) * 0.25;\n    shift = (iIntensity * 0.5 + 0.5) * shift + vec2(0., 0.5 - 0.5 * iIntensity);\n    shift /= aspectCorrection;\n\n    vec2 uv2 = uv + shift;\n    vec4 color = vec4(1., uv2.y * 0.6, 0., 1.0);\n    color *= smoothstep(0.1, 0.3, (1. - uv2.y));\n    color *= smoothstep(0., 0.2, iIntensity);\n\n    fragColor = composite(fragColor, color);\n}\n", 
    "resources/effects/unstable.glsl": "#property description Unstable second-order system\n\nvoid main(void) {\n    vec4 y1 = demultiply(texture(iChannel[0], uv));\n    vec4 y2 = demultiply(texture(iChannel[1], uv));\n    vec4 original = texture(iInput, uv);\n    vec4 x0 = demultiply(original);\n\n    vec4 y0;\n    y0.rgb = 1.11 * y1.rgb - 9.0 * y2.rgb + 1.0 * x0.rgb;\n    y0.a = x0.a;\n\n    fragColor = mix(original, premultiply(y0), iIntensity);\n}\n\n#buffershader\n\nvoid main(void) {\n    // Delay \n    fragColor = texture(iChannel[0], uv);\n}\n", 
    "resources/effects/jet.glsl": "#property description Matlab-ify the colors\n#property author https://github.com/kbinani/glsl-colormap\n\n// [ From https://github.com/kbinani/glsl-colormap/blob/master/shaders/MATLAB_jet.frag\nfloat colormap_red(float x) {\n    if (x < 0.7) {\n        return 4.0 * x - 1.5;\n    } else {\n        return -4.0 * x + 4.5;\n    }\n}\nfloat colormap_green(float x) {\n    if (x < 0.5) {\n        return 4.0 * x - 0.5;\n    } else {\n        return -4.0 * x + 3.5;\n    }\n}\nfloat colormap_blue(float x) {\n    if (x < 0.3) {\n       return 4.0 * x + 0.5;\n    } else {\n       return -4.0 * x + 2.5;\n    }\n}\nvec4 colormap(float x) {\n    float r = clamp(colormap_red(x), 0.0, 1.0);\n    float g = clamp(colormap_green(x), 0.0, 1.0);\n    float b = clamp(colormap_blue(x), 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// ]\n\nvoid main(void) {\n    vec4 origColor = texture(iInput, uv);\n    vec3 hsv = rgb2hsv(demultiply(origColor).rgb);\n\n    float h = mod(0.90 - hsv.x, 1.0);\n    vec4 c = colormap(h);                   // Hue\n    c.rgb = mix(vec3(1.0), c.rgb, hsv.y);   // Sat\n    c.rgb *= hsv.z;                         // Val\n    c *= origColor.a;                       // Alpha\n\n    fragColor = mix(origColor, c, iIntensity);\n}\n", 
    "resources/effects/delace.glsl": "#property description Deinterlacing artifacts\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n\n    float oddEven = mod(floor(uv.x * iResolution.x), 2.0); // either 0 or 1\n\n    vec2 offset = vec2(0.);\n    offset.x += 0.09 * smoothstep(0.0, 0.5, iIntensity);\n    offset.x += 0.04 * smoothstep(0.2, 0.6, iIntensity) * rand(vec2(iTime, uv.y / 1000.));\n    offset.x += 0.03 * smoothstep(0.4, 0.9, iIntensity) * sawtooth(iIntensityIntegral, 0.1);\n    offset.y += 0.05 * smoothstep(0.8, 1.0, iIntensity);\n\n    vec4 offColor = texture(iInput, clamp(uv + offset, 0., 1.));\n    fragColor = mix(fragColor, offColor, oddEven * iIntensity);\n}\n", 
    "resources/effects/onblack.glsl": "#property description Composite the input image onto black\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    fragColor.a = mix(fragColor.a, 1.0, iIntensity);\n}\n", 
    "resources/effects/gstrobe.glsl": "#property description Strobe alpha to the beat\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c;\n\n    float freq;\n    if(iIntensity < 0.05) freq = 0.;\n    else if(iIntensity < 0.45) freq = 2.;\n    else freq = 1.;\n\n    if(freq > 0.) {\n        float i = (1. - sawtooth(iTime / freq, 0.1)) * min(3. * iAudioLevel, 1.);\n        fragColor.r *= i;\n        fragColor.b *= i;\n        fragColor.g *= 1. - i;\n    }\n}\n", 
    "resources/effects/flow.glsl": "#property description Radiate color from the center based on audio\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c = texture(iChannel[1], uv);\n    c *= smoothstep(0., 0.2, iIntensity);\n    fragColor = composite(c, fragColor);\n}\n#buffershader\nvoid main(void) {\n\n    fragColor = texture(iChannel[1], (uv - 0.5) * 0.98 + 0.5);\n    fragColor *= exp((iIntensity - 2.) / 50.) * smoothstep(0., 0.01, length((uv - 0.5) * aspectCorrection));\n\n    vec4 c = texture(iInput, uv);\n    float s = smoothstep(0.90, 1., 1. - mod(iTime, 1.)) * mix(0.01, 1.0, iAudioLevel);\n    c *=  min(3. * s, 1.);\n    fragColor = composite(fragColor, c);\n}\n", 
    "resources/effects/starfield.glsl": "#property description Pixels radiating from the center\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c = texture(iChannel[1], uv);\n    c *= smoothstep(0., 0.2, iIntensity);\n    fragColor = composite(fragColor, c);\n}\n#buffershader\nvoid main(void) {\n    fragColor = texture(iChannel[1], (uv - 0.5) * 0.99 + 0.5);\n    fragColor *= exp(-1. / 20.);\n    if (rand(vec3(uv, iTime)) < exp((iIntensity - 2.) * 4.))\n        fragColor = vec4(1.);\n}\n", 
    "resources/effects/rjump.glsl": "#property description Shift the hue on the beat\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    \n    float t;\n    if (iIntensity < 0.85)\n        t = iTime / 4.0;\n    else if (iIntensity < 0.95)\n        t = iTime / 2.0;\n    else\n        t = iTime;\n\n    float deviation = mod(2. * floor(t), 8.) / 8.;\n    deviation *= clamp(iIntensity / 0.8, 0., 1.);\n\n    vec3 hsv = rgb2hsv(fragColor.rgb);\n    hsv.r = mod(hsv.r + 1. + deviation, 1.);\n    fragColor.rgb = hsv2rgb(hsv);\n}\n", 
    "resources/effects/red.glsl": "#property description Change the color (in HSV) to red\n\nvoid main(void) {\n    vec4 c = texture(iInput, uv);\n    fragColor.r = mix(c.r, (c.r + c.g + c.b) / 3., iIntensity);\n    fragColor.g = c.g * (1. - iIntensity);\n    fragColor.b = c.b * (1. - iIntensity);\n    fragColor.a = c.a;\n    fragColor = clamp(fragColor, 0.0, 1.0);\n}\n", 
    "resources/effects/inception.glsl": "#property description Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Modified for Radiance by Eric Van Albert\n\n#define MAX_DEPTH 12\n\nvec4 lookup(vec2 coord) {\n    return texture(iInput, coord / aspectCorrection + 0.5);\n}\n\nvoid main() {\n    float depth = iIntensity * float(MAX_DEPTH);\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2  d = -normCoord / depth;\n    float w = 3. / depth;\n    vec2  s = normCoord;\n    vec4 col = lookup(s);\n    for( int i=0; i<MAX_DEPTH; i++ ) {\n        if (float(i) >= depth)\n            break;\n\n        w *= .99;\n        s += d;\n        vec4 res = lookup(s);\n        //res = smoothstep(0., 1., res); // Makes colors more vibrant\n        res *= max(res.r, max(res.g, res.b));\n        res *= w;\n        col = composite(col, res);\n    }\n\n\tfragColor = col;\n}\n", 
    "resources/effects/posterh.glsl": "#property description Reduce number of hues in HSV space\n\nvoid main(void) {\n    float bins = min(360., 6. / iIntensity);\n    \n    vec4 hsv = demultiply(texture(iInput, uv));\n    hsv.rgb = rgb2hsv(hsv.rgb);\n    hsv.r = mod(round(hsv.r * bins) / bins, 1.0);\n    hsv.rgb = hsv2rgb(hsv.rgb);\n\n    fragColor = premultiply(hsv);\n}\n", 
    "resources/effects/greenscreen.glsl": "#property description Replace green parts of the first input with the second\n#property inputCount 2\nvoid main() {\n    vec4 m = texture(iInputs[0], uv);\n    vec4 g = texture(iInputs[1], uv);\n\n    fragColor = m;\n\n    // x is 1.0 in pure green areas and ~0.0 elsewhere\n    m = demultiply(m); // don't use alpha to detect green-ness\n    float x = pow(clamp(m.g - (m.r + m.b) * 3.0, 0.0, 1.0), 0.2);\n    x *= m.a; // Put alpha back in\n\n    fragColor = composite(fragColor, g * x * iIntensity);\n}\n", 
    "resources/effects/scramble.glsl": "#property description Scramble up input blocks\n\nvoid main(void) {\n    vec4 secondary = texture(iChannel[1], uv);\n    vec2 uvNew = mix(uv, secondary.xy, smoothstep(0.0, 0.2, iIntensity));\n    fragColor = texture(iInput, uvNew);\n}\n\n#buffershader\n\nvec2 pixelate(vec2 xy, float n_buckets) {\n    vec2 xy_buckets = n_buckets * aspectCorrection;\n    xy -= 0.5;\n    xy = round(xy * xy_buckets) / xy_buckets;\n    xy += 0.5;\n    return xy;\n}\n\nbool in_bucket(vec2 uv, vec2 xy, float n_buckets) {\n    vec2 d = abs(uv - xy) * n_buckets;\n    return max(d.x, d.y) <= 0.5;\n}\n\nvoid main(void) {\n    float n_buckets = 10.;\n\n    vec2 left = vec2(rand(vec2(iTime, 0.)), rand(vec2(iTime, 1.)));\n    left = pixelate(left, n_buckets);\n    vec2 right = vec2(rand(vec2(iTime, 2.)), rand(vec2(iTime, 3.)));\n    right = pixelate(right, n_buckets);\n\n    vec4 newColor = texture(iChannel[1], uv);\n    if (in_bucket(uv, left, n_buckets)) {\n        vec2 newCoord = uv - left + right;\n        float oldDist = distance(newColor.xy, uv);\n        float newDist = distance(newCoord, uv);\n        float improvement = oldDist - newDist; // positive means reverting to normal\n        if (improvement > -1.8 * iIntensity + 0.5) {\n            newColor = vec4(newCoord, 1., 1.);\n        }\n        if (iIntensity < 0.3) {\n            newColor = vec4(uv.xy, 1., 1.);\n        }\n    }\n\n    fragColor = mix(\n        vec4(uv.xy, 1., 1.),\n        newColor,\n        step(0.05, iIntensity)\n    );\n}\n", 
    "resources/effects/spinb.glsl": "#property description Spins the pattern round to the beat\n\nvoid main(void) {\n    float r;\n    float freq;\n    if(iIntensity < 0.05) freq = 0.;\n    else if(iIntensity < 0.25) freq = 32.;\n    else if(iIntensity < 0.35) freq = 16.;\n    else if(iIntensity < 0.45) freq = 8.;\n    else if(iIntensity < 0.55) freq = 4.;\n    else if(iIntensity < 0.65) freq = 2.;\n    else if(iIntensity < 0.75) freq = 1.;\n    else if(iIntensity < 0.85) freq = 0.5;\n    else freq = 0.25;\n\n    if(freq > 0.) {\n        r = mod(iTime, freq) / freq;\n    } else {\n        r = 0.; \n    }\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float s = sin(r * M_PI);\n    float c = cos(r * M_PI);\n    mat2 rot = mat2(c, -s, s, c);\n\n    vec2 newUV = normCoord * rot / aspectCorrection;\n    newUV *= min(iResolution.x, iResolution.y) / max(iResolution.x, iResolution.y);\n    newUV += 0.5;\n\n    vec4 oc = texture(iInput, uv);\n    vec4 nc = texture(iInput, newUV);\n    nc *= box(newUV);\n\n    fragColor = mix(oc, nc, smoothstep(0., 0.2, iIntensity));\n}\n", 
    "resources/effects/saturate.glsl": "#property description Saturate colors in HSV space\n\nvoid main(void) {\n    vec4 origColor = texture(iInput, uv);\n    vec3 hsv = rgb2hsv(demultiply(origColor).rgb);\n    //hsv.yz = mix(hsv.yz, vec2(1.0, 1.0), iIntensity);\n    hsv.y = mix(hsv.y, 1., iIntensity);\n    fragColor.rgb = hsv2rgb(hsv);\n    fragColor.a = 1.0;\n    fragColor *= origColor.a;\n}\n\n", 
    "resources/effects/bespecklep.glsl": "#property description Brownian-ish speckle effect with perlin noise\n\nvoid main(void) {\n    vec4 old = texture(iChannel[0], uv);\n    vec4 new = texture(iInput, uv);\n\n    float r = noise(vec3(uv * 16., iTime * 16.));\n    float k = pow(mix(1.0, r, iIntensity), 2.0);\n    fragColor = mix(old, new, k);\n\n    // I don't think this is required, but just be safe\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, fragColor.a);\n}\n", 
    "resources/effects/flowing.glsl": "#property description Sort of like rainbow but for lightness, avoiding the edges\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec3 hsv = rgb2hsv(fragColor.rgb);\n\n    float deviation = mod(iTime * 0.5, 1.);\n    float spatialFrequency = 8.;\n    float newLightness = hsv.z * mod(spatialFrequency * hsv.z + deviation, 1.);\n\n    float amount = iIntensity;\n\n    // Avoid the edges to smooth the discontinuity\n    amount *= smoothstep(0., 0.4, newLightness);\n    amount *= 1. - smoothstep(0.6, 1., newLightness);\n\n    hsv.z = mix(hsv.z, newLightness, amount);\n    fragColor.rgb = hsv2rgb(hsv);\n}\n", 
    "resources/effects/outline.glsl": "#property description Apply black outline around edges\n#property author https://www.shadertoy.com/view/XssGD7 + zbanks\n\nvoid main()\n{\n\t// Sobel operator\n\tfloat off = onePixel;\n\tvec3 o = vec3(-off, 0.0, off);\n\tvec4 gx = vec4(0.0);\n\tvec4 gy = vec4(0.0);\n\tvec4 t;\n\tgx += texture(iInput, uv + o.xz);\n\tgy += gx;\n\tgx += 2.0*texture(iInput, uv + o.xy);\n\tt = texture(iInput, uv + o.xx);\n\tgx += t;\n\tgy -= t;\n\tgy += 2.0*texture(iInput, uv + o.yz);\n\tgy -= 2.0*texture(iInput, uv + o.yx);\n\tt = texture(iInput, uv + o.zz);\n\tgx -= t;\n\tgy += t;\n\tgx -= 2.0*texture(iInput, uv + o.zy);\n\tt = texture(iInput, uv + o.zx);\n\tgx -= t;\n\tgy -= t;\n\tvec4 grad = sqrt(gx * gx + gy * gy);\n\n    float black = clamp(1.0 - length(grad) * 0.9, 0., 1.);\n    black = pow(black, mix(1.0, 2.0, iIntensity));\n\n    vec4 newColor = texture(iInput, uv);\n    newColor.rgb *= mix(1.0, black, smoothstep(0.0, 0.5, iIntensity));\n    fragColor = newColor;\n}\n", 
    "resources/effects/fly.glsl": "#property description 3D flying view\n#property author inigo quilez (iq/2013), modified by Eric Van Albert\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Modified for radiance by Eric Van Albert\n\nvoid main()\n{\n    float an = iTime*0.2;\n    vec2 p = mat2(cos(an),-sin(an),sin(an),cos(an)) * (-1. + 2. * uv);\n    vec2 puv = vec2(p.x,1.0)/abs(p.y) + vec2(0., 4.) * iIntensityIntegral;\n    puv = abs(mod(0.2 * puv, 2.) - 1.);\n\n    puv = mix(uv, puv, smoothstep(0.0, 0.2, iIntensity));\n    vec4 c = texture(iInput, puv);\n    //c.a *= abs(uv.y * 0.8);\n    c.a = mix(c.a, c.a * min(abs(p.y)* 3.8, 1.), smoothstep(0.0, 0.2, iIntensity));\n\tfragColor = premultiply(c);\n}\n", 
    "resources/glsl/effect_header.glsl": "#version 150\n\n#ifdef GL_ES\nprecision mediump float;\nvarying highp vec2 uv;\n#define fragColor gl_FragColor\n#define _FLEXARRAY 8\n#define texture texture2D\n#else\nin vec4 gl_FragCoord;\nin vec2 uv;\nout vec4 fragColor;\n#define _FLEXARRAY\n#endif\n\n// Time, measured in beats. Wraps around to 0 every 16 beats, [0.0, 16.0)\nuniform highp float iStep;\nuniform highp float iTime;\n\n// Audio levels, high/mid/low/level, [0.0, 1.0]\nuniform vec4  iAudio;\n#define iAudioLow   iAudio.x\n#define iAudioMid   iAudio.y\n#define iAudioHi    iAudio.z\n#define iAudioLevel iAudio.w\n\n// Resolution of the output pattern\nuniform vec2 iResolution;\n\n// Intensity slider, [0.0, 1.0]\nuniform lowp float iIntensity;\n\n// Intensity slider integrated with respect to wall time mod 1024, [0.0, 1024.0)\nuniform float iIntensityIntegral;\n\n// (Ideal) output rate in frames per second\nuniform float iFPS;\n\n// Outputs of previous patterns\nuniform sampler2D iInputs[_FLEXARRAY];\n\n// Output of the previous pattern.  Alias to iInputs[0]\n#define iInput iInputs[0]\n\n// Full frame RGBA noise\nuniform sampler2D iNoise;\n\n// Previous outputs of the other channels (e.g. foo.1.glsl)\nuniform sampler2D iChannel[_FLEXARRAY];\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat lin_step(float v) {\n    return v * iStep * iFPS;\n}\nfloat exp_step(float v) {\n    return pow(v, iStep * iFPS);\n}\n// Utilities to convert from an RGB vec3 to an HSV vec3\n// 0 <= H, S, V <= 1\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Utilities to convert from an RGB vec3 to a YUV vec3\n// 0 <= Y, U, V <= 1 (*not* -1 <= U, V <= 1)\n// U is greenish<->bluish; V is bluish<->redish\n// https://en.wikipedia.org/wiki/YUV#Full_swing_for_BT.601\nvec3 rgb2yuv(vec3 rgb) {\n    vec3 yuv = vec3(0.);\n    yuv.x = rgb.r *  0.2126  + rgb.g *  0.7152  + rgb.b *  0.0722;\n    yuv.y = rgb.r * -0.09991 + rgb.g * -0.33609 + rgb.b *  0.436;\n    yuv.z = rgb.r *  0.615   + rgb.g * -0.55861 + rgb.b * -0.05639;\n    yuv.yz += 1.0;\n    yuv.yz *= 0.5;\n    return yuv;\n}\nvec3 yuv2rgb(vec3 yuv) {\n    yuv.yz /= 0.5;\n    yuv.yz -= 1.0;\n    vec3 rgb = vec3(0.);\n    rgb.r = yuv.x +                    yuv.z *  1.28033;\n    rgb.g = yuv.x + yuv.y * -0.21482 + yuv.z * -0.38059;\n    rgb.b = yuv.x + yuv.y *  2.12798;\n    return clamp(rgb, 0.0, 1.0);\n}\n\n// Turn non-premultipled alpha RGBA into premultipled alpha RGBA\nvec4 premultiply(vec4 c) {\n    return vec4(c.rgb * c.a, c.a);\n}\n\n// Turn premultipled alpha RGBA into non-premultipled alpha RGBA\nvec4 demultiply(vec4 c) {\n    return clamp(vec4(c.rgb / c.a, c.a), vec4(0.), vec4(1.));\n}\n\n// Alpha-compsite two colors, putting one on top of the other. Everything is premultipled\nvec4 composite(vec4 under, vec4 over) {\n    float a_out = 1. - (1. - over.a) * (1. - under.a);\n    return clamp(vec4((over.rgb + under.rgb * (1. - over.a)), a_out), vec4(0.), vec4(1.));\n}\n\n// Sawtooth wave\nfloat sawtooth(float x, float t_up) {\n    x = mod(x + t_up, 1.);\n    return x / t_up * step(x, t_up) +\n           (1. - x) / (1. - t_up) * (1. - step(x, t_up));\n}\n\n// Box from [0, 0] to (1, 1)\nfloat box(vec2 p) {\n    vec2 b = step(0., p) - step(1., p);\n    return b.x * b.y;\n}\n\n// Predictable randomness\nfloat rand(float c){\n    return fract(sin(c * 12.9898) * 43758.5453);\n}\n\nfloat rand(vec2 c){\n    return fract(sin(dot(c, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 c){\n    return fract(sin(dot(c, vec3(12.9898,78.233, 52.942))) * 43758.5453);\n}\n\nfloat rand(vec4 c){\n    return fract(sin(dot(c, vec4(12.9898, 78.233, 52.942, 35.291))) * 43758.5453);\n}\n\nfloat noise(float p) {\n    float i = floor(p);\n    float x = mod(p, 1.);\n    // x = .5*(1.-cos(M_PI*x));\n    x = 3.*x*x-2.*x*x*x;\n    float a = rand(i+0.);\n    float b = rand(i+1.);\n    return mix(a, b, x);\n}\n\nfloat noise(vec2 p) {\n    vec2 ij = floor(p);\n    vec2 xy = mod(p, 1.);\n    // xy = .5*(1.-cos(M_PI*xy));\n    xy = 3.*xy*xy-2.*xy*xy*xy;\n    float a = rand((ij+vec2(0.,0.)));\n    float b = rand((ij+vec2(1.,0.)));\n    float c = rand((ij+vec2(0.,1.)));\n    float d = rand((ij+vec2(1.,1.)));\n    float x1 = mix(a, b, xy.x);\n    float x2 = mix(c, d, xy.x);\n    return mix(x1, x2, xy.y);\n}\n\nfloat noise(vec3 p) {\n    vec3 ijk = floor(p);\n    vec3 xyz = mod(p, 1.);\n    // xyz = .5*(1.-cos(M_PI*xyz));\n    xyz = 3.*xyz*xyz-2.*xyz*xyz*xyz;\n    float a = rand((ijk+vec3(0.,0.,0.)));\n    float b = rand((ijk+vec3(1.,0.,0.)));\n    float c = rand((ijk+vec3(0.,1.,0.)));\n    float d = rand((ijk+vec3(1.,1.,0.)));\n    float e = rand((ijk+vec3(0.,0.,1.)));\n    float f = rand((ijk+vec3(1.,0.,1.)));\n    float g = rand((ijk+vec3(0.,1.,1.)));\n    float h = rand((ijk+vec3(1.,1.,1.)));\n    float x1 = mix(a, b, xyz.x);\n    float x2 = mix(c, d, xyz.x);\n    float y1 = mix(x1, x2, xyz.y);\n    float x3 = mix(e, f, xyz.x);\n    float x4 = mix(g, h, xyz.x);\n    float y2 = mix(x3, x4, xyz.y);\n    return mix(y1, y2, xyz.z);\n}\n\nfloat noise(vec4 p) {\n    vec4 ijkl = floor(p);\n    vec4 xyzw = mod(p, 1.);\n    // xyz = .5*(1.-cos(M_PI*xyz));\n    xyzw = 3.*xyzw*xyzw-2.*xyzw*xyzw*xyzw;\n    float a = rand((ijkl+vec4(0.,0.,0.,0.)));\n    float b = rand((ijkl+vec4(1.,0.,0.,0.)));\n    float c = rand((ijkl+vec4(0.,1.,0.,0.)));\n    float d = rand((ijkl+vec4(1.,1.,0.,0.)));\n    float e = rand((ijkl+vec4(0.,0.,1.,0.)));\n    float f = rand((ijkl+vec4(1.,0.,1.,0.)));\n    float g = rand((ijkl+vec4(0.,1.,1.,0.)));\n    float h = rand((ijkl+vec4(1.,1.,1.,0.)));\n    float i = rand((ijkl+vec4(0.,0.,0.,1.)));\n    float j = rand((ijkl+vec4(1.,0.,0.,1.)));\n    float k = rand((ijkl+vec4(0.,1.,0.,1.)));\n    float l = rand((ijkl+vec4(1.,1.,0.,1.)));\n    float m = rand((ijkl+vec4(0.,0.,1.,1.)));\n    float n = rand((ijkl+vec4(1.,0.,1.,1.)));\n    float o = rand((ijkl+vec4(0.,1.,1.,1.)));\n    float q = rand((ijkl+vec4(1.,1.,1.,1.)));\n    float x1 = mix(a, b, xyzw.x);\n    float x2 = mix(c, d, xyzw.x);\n    float y1 = mix(x1, x2, xyzw.y);\n    float x3 = mix(e, f, xyzw.x);\n    float x4 = mix(g, h, xyzw.x);\n    float y2 = mix(x3, x4, xyzw.y);\n    float z1 = mix(y1, y2, xyzw.z);\n\n    float x5 = mix(i, j, xyzw.x);\n    float x6 = mix(k, l, xyzw.x);\n    float y3 = mix(x5, x6, xyzw.y);\n    float x7 = mix(m, n, xyzw.x);\n    float x8 = mix(o, q, xyzw.x);\n    float y4 = mix(x7, x8, xyzw.y);\n    float z2 = mix(y3, y4, xyzw.z);\n    return mix(z1, z2, xyzw.w);\n}\nfloat hmax(vec2 v) {\n    return max(v.r,v.g);\n}\nfloat hmax(vec3 v) {\n    return max(hmax(v.rg),v.b);\n}\nfloat hmax(vec4 v) {\n    return hmax(max(v.rg,v.ba));\n}\n\n#ifdef GL_ES\n// Shim functions for ES\nfloat round(float x) {\n    return floor(x + 0.5);\n}\nvec2 round(vec2 x) {\n    return floor(x + 0.5);\n}\nvec3 round(vec3 x) {\n    return floor(x + 0.5);\n}\nvec4 round(vec4 x) {\n    return floor(x + 0.5);\n}\nfloat modf(float x, out float integralPart) {\n    integralPart = floor(x);\n    return x - integralPart;\n}\n#endif\n\n// FIXME\n#ifdef GL_ES\n#define onePixel (1.0 / min(iResolution.x, iResolution.y))\n#define aspectCorrection (iResolution / min(iResolution.x, iResolution.y))\n#else\nvec2 aspectCorrection = iResolution / min(iResolution.x, iResolution.y);\nfloat onePixel = 1. / min(iResolution.x, iResolution.y);\n#endif\n", 
    "resources/effects/desatb.glsl": "#property description Desaturate to the beat (in HSV space)\n\nvoid main(void) {\n    float t = mod(iTime, 4.0) / 4.0;\n    float factor = pow(iIntensity * t, 2.5);\n\n    vec4 samp = texture(iInput, uv);\n    vec3 hsl = rgb2hsv(samp.rgb);\n    hsl.g *= 1.0 - factor;\n    fragColor.rgb = hsv2rgb(hsl);\n    fragColor.a = samp.a;\n    fragColor = premultiply(fragColor);\n}\n", 
    "resources/effects/allwhite.glsl": "#property description Basic white fill\n\nvoid main(void) {\n    vec4 white = vec4(1.) * iIntensity;\n    fragColor = composite(texture(iInput, uv), white);\n}\n", 
    "resources/effects/luma.glsl": "#property description Makes black transparent (luma keying)\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n\n    float luma = 1. - (1. - fragColor.r) * (1. - fragColor.g) * (1. - fragColor.b);\n    float a_out = luma / max(0.001, (iIntensity - 0.1) / 0.9); // Full black always becomes transparent, but this curve sets how almost-black things behave\n    a_out = max(a_out, 1. - 10. * iIntensity); // For the first 10%, fade from identity to luma-keyed image (makes the transition more continuous and pleasing)\n    a_out = min(a_out, fragColor.a); // Never get more opaque than the original image\n    fragColor.a = a_out;\n}\n", 
    "resources/effects/sethue.glsl": "#property description Set the color in HSV space\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec3 hsv = rgb2hsv(fragColor.rgb);\n    hsv.x = max((iIntensity - 0.1) / 0.9, 0.);\n    fragColor.rgb = mix(fragColor.rgb, hsv2rgb(hsv), smoothstep(0., 0.1, iIntensity));\n}\n", 
    "resources/effects/coin.glsl": "#property description Rotate the 'object' in 3D, like a coin\n\n#define WIDTH 0.1\n#define ITERS 64\n\nvec4 lookup(vec2 coord) {\n    vec2 xy = coord / aspectCorrection + 0.5;\n    xy = clamp(xy, 0., 1.);\n    return texture(iInput, xy);\n}\n\nvoid main() {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2  d = vec2(WIDTH, 0.) / float(ITERS);\n    vec2  s = normCoord;\n    //float phi = iIntensityIntegral * 4;\n    float phi = iTime * 1.0;\n    s.x /= sin(phi);\n\n    // This isn't quite right, but it's super easy compared to real geometry\n    d *= abs(cos(phi)) * sign(sin(phi * 2.));\n\n    vec4 col = lookup(s);\n    for( int i=0; i<ITERS; i++ )\n    {\n        s += d;\n        vec4 res = lookup(s);\n        col = composite(res, col);\n    }\n\n    fragColor = lookup(normCoord);\n\tfragColor = mix(fragColor, col, smoothstep(0.0, 0.2, iIntensity));\n}\n", 
    "resources/effects/survey.glsl": "#property description Zoom in and pan across the surface\n\nvoid main(void) {\n    float t = iTime * 2. *  M_PI / 64.;\n    vec2 sweep = vec2(cos(3. * t), sin(2. * t));\n\n    float amount = iIntensity * 0.5;\n\n    float factor = (1. - 2. * amount);\n\n    vec2 newUV = (uv - 0.5) * factor + sweep * amount + 0.5;\n\n    fragColor = texture(iInput, newUV) * box(newUV);\n}\n", 
    "resources/effects/count.glsl": "#property description Count out the beats\n// This looks really dumb if BTrack doesn't do a good job :/\n\nfloat dist(vec2 point, vec2 xbound, float y) {\n    // L1 distance function from a point to a X axis-aligned line segment\n    // Line segment has endpoints `(xbound.x, y), (xbound.y, y)`\n\n    // Distance from line\n    float d = abs(point.y - y);\n\n    // L1 distance from endpoints (to give sharp, diamond corners)\n    d += step(point.x, xbound.x) * (xbound.x - point.x);\n    d += step(xbound.y, point.x) * (point.x - xbound.y);\n\n    return d;\n}\n\nfloat bound(float low, float high, float eps, float t) {\n    // Smooth 'box'-like function; returns 1.0 if t in [low, high] and 0.0 if outside\n    // eps is a smoothing factor\n    return smoothstep(low - eps, low + eps, t) - smoothstep(high - eps, high + eps, t);\n}\n\nvoid main(void) {\n    // 7-seg display; not all segments are actually used\n    //\n    //  AAA\n    // F   B\n    // F   B\n    //  GGG\n    // E   C\n    // E   C\n    //  DDD\n\n    float a = dist(uv.xy, vec2(0.40, 0.60), 0.80);\n    float b = dist(uv.yx, vec2(0.55, 0.75), 0.65);\n    float c = dist(uv.yx, vec2(0.25, 0.45), 0.65);\n    float d = dist(uv.xy, vec2(0.40, 0.60), 0.20);\n    float e = dist(uv.yx, vec2(0.25, 0.45), 0.35);\n    float f = dist(uv.yx, vec2(0.55, 0.75), 0.35);\n    float g = dist(uv.xy, vec2(0.40, 0.60), 0.50);\n\n    // Font for 4 digits\n    float one = min(b, c);\n    float two = min(min(a, b), min(d, min(e, g)));\n    float three = min(min(a, b), min(c, min(d, g)));\n    float four = min(min(b, c), min(f, g));\n\n    // Cycle through 4 digits based on beat counter, slight fade between #s\n    float t = mod(iTime, 4.0);\n    float tOff = mod(iTime + 2.0, 4.0);\n    float totalDist = one   * bound(2.0, 3.0, 0.10, tOff) \n                    + two   * bound(1.0, 2.0, 0.10, t) \n                    + three * bound(2.0, 3.0, 0.10, t)\n                    + four  * bound(1.0, 2.0, 0.10, tOff);\n\n    float alpha = 1.0 - smoothstep(0.02, 0.04, totalDist);\n    alpha = clamp(0., 1., alpha);\n\n    vec4 color = vec4(1.0, 0.2, 0.0, 1.0); // Red\n    color *= alpha;\n    color *= iIntensity;\n\n    fragColor = composite(texture(iInput, uv), color);\n}\n", 
    "resources/effects/hue.glsl": "#property description Shift the color in HSV space\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec3 hsv = rgb2hsv(fragColor.rgb);\n    hsv.x = mod(hsv.x + iIntensity, 1.0);\n    fragColor.rgb = hsv2rgb(hsv);\n}\n", 
    "resources/effects/lathe.glsl": "#property description Like you're looking at the image reflected in something that was surfaced on a lathe\n\nvoid main(void) {\n    vec2 normCoord = 2. * (uv - 0.5);\n    normCoord *= aspectCorrection;\n\n    // Look up r and theta\n    float r = length(normCoord);\n    float theta = atan(normCoord.y, normCoord.x);\n\n    // Image is sampled along a vertical line that slowly shifts back and forth\n    // and this line is then swept into a circle\n    // Get two newUVs, one for the top half and one for the bottom half\n    vec2 newUV1 = vec2(sin(iIntensityIntegral * 0.2), r);\n    vec2 newUV2 = vec2(sin(iIntensityIntegral * 0.2), -r);\n    newUV1 /= aspectCorrection;\n    newUV1 = newUV1 * 0.5 + 0.5;\n    newUV2 /= aspectCorrection;\n    newUV2 = newUV2 * 0.5 + 0.5;\n\n    // Make them both converge to the old UV at low intensity so that identity holds\n    newUV1 = mix(uv, newUV1, smoothstep(0., 0.3, iIntensity));\n    newUV2 = mix(uv, newUV2, smoothstep(0., 0.3, iIntensity));\n\n    vec4 c1 = texture(iInput, newUV1);\n    vec4 c2 = texture(iInput, newUV2);\n\n    // Mix them based on angle\n    fragColor = mix(c2, c1, smoothstep(-0.5, 0.5, sin(theta)));\n}\n", 
    "resources/effects/pan.glsl": "#property description Move input horizontally\n\nvoid main()\n{\n    vec2 pt = uv;\n    pt.x = mod(pt.x + iIntensity,1.);\n    fragColor = texture(iInputs[0], pt);\n}\n", 
    "resources/effects/cedge.glsl": "#property description Derivative of https://www.shadertoy.com/view/XssGD7, with tighter edges.\n\nvec4 get_texture(vec2 off, vec2 cor) {\n    return texture(iInput, uv + off * cor);\n}\n\nvoid main()\n{\n\t// Sobel operator\n    float off = 8. * iIntensity;\n    vec2  cor = 1. / iResolution.xy;\n\tvec3 o = vec3(-off, 0.0, off);\n\tvec4 gx = vec4(0.0);\n\tvec4 gy = vec4(0.0);\n\tvec4 t;\n\tgx += get_texture(o.xz,cor);\n\tgy += gx;\n\tgx += 2.0*get_texture(o.xy,cor);\n\tt = get_texture(o.xx,cor);\n\tgx += t;\n\tgy -= t;\n\tgy += 2.0*get_texture(o.yz,cor);\n\tgy -= 2.0*get_texture(o.yx,cor);\n\tt = get_texture(o.zz,cor);\n\tgx -= t;\n\tgy += t;\n\tgx -= 2.0*get_texture(o.zy,cor);\n\tt = get_texture(o.zx,cor);\n\tgx -= t;\n\tgy -= t;\n\tvec4 grad = sqrt(gx * gx + gy * gy);\n    grad.xyz /= sqrt(off);\n    grad.a = max(max(grad.r, grad.g), max(grad.b, grad.a));\n\n    vec4 original = texture(iInput, uv);\n    if(iIntensity > 0.) {\n        fragColor = grad;\n    }else{\n        fragColor = original;\n    }\n}\n", 
    "resources/effects/rblur.glsl": "#property description Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Modified for Radiance by Eric Van Albert\n\n#define DEPTH 64\n\nvec4 lookup(vec2 coord) {\n    return texture(iInput, coord / aspectCorrection + 0.5);\n}\n\nvoid main() {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2  d = -normCoord / float(DEPTH);\n    float w = iIntensity * 4. / float(DEPTH);\n    vec2  s = normCoord;\n    vec4 col = lookup(s);\n    for( int i=0; i<DEPTH; i++ )\n    {\n        w *= .99;\n        s += d;\n        vec4 res = lookup(s);\n        //res = smoothstep(0., 1., res); // Makes colors more vibrant\n        res *= max(res.r, max(res.g, res.b));\n        res *= w;\n        col = composite(col, res);\n    }\n\n\tfragColor = col;\n}\n", 
    "resources/effects/strobe.glsl": "#property description Strobe alpha to the beat\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec4 c;\n\n    float freq;\n    if(iIntensity < 0.05) freq = 0.;\n    else if(iIntensity < 0.45) freq = 2.;\n    else freq = 1.;\n\n    if(freq > 0.) {\n        fragColor *= 1. - ((1. - sawtooth(iTime / freq, 0.2)) * smoothstep(0., 0.2, iIntensity) * min(3. * iAudioLevel, 1.));\n    }\n}\n", 
    "resources/glsl/plain_fragment.glsl": "varying highp vec2 uv;\nuniform sampler2D iTexture;\nvoid main() {\n    gl_FragColor = texture2D(iTexture, uv);\n}\n", 
    "resources/effects/yuvrot.glsl": "#property description Shift the color in YUV space by rotating on the UV plane\n\nvoid main(void) {\n    fragColor = texture(iInput, uv);\n    vec3 yuv = rgb2yuv(demultiply(fragColor).rgb);\n\n    float t = iIntensity * 2. * M_PI;\n    yuv.gb *= 2.;\n    yuv.gb -= 1.;\n    yuv.gb = vec2(yuv.g * cos(t) - yuv.b * sin(t),\n                  yuv.g * sin(t) + yuv.b * cos(t));\n    yuv.gb += 1.;\n    yuv.gb /= 2.;\n\n    fragColor.rgb = yuv2rgb(yuv) * fragColor.a;\n}\n"
})