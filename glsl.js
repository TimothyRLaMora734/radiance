loadGlsl({
    "resources/effects/hue.0.glsl": "// Shift the color in HSV space\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    vec3 hsv = rgb2hsv(gl_FragColor.rgb);\n    hsv.x = mod(hsv.x + iIntensity, 1.0);\n    gl_FragColor.rgb = hsv2rgb(hsv);\n}\n", 
    "resources/effects/circle.0.glsl": "// Yellow blob that spins to the beat\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float t = iTime / 4.0;\n    vec2 center = vec2(sin(t), cos(t));\n    //center *= 0.5;\n    center *= iAudioLevel * 0.9 + 0.1;\n\n    vec4 c = vec4(1., 1., 0., 1.);\n    c.a = clamp(length(center - normCoord), 0, 1);\n    c.a = pow(c.a, iAudioHi * 3 + 0.1);\n    c.a = 1.0 - c.a;\n    c.a *= iIntensity;\n\n    gl_FragColor = composite(texture2D(iFrame, uv), c);\n}\n", 
    "resources/effects/desat.0.glsl": "// Desaturate (make white)\n\nvoid main(void) {\n    float factor = pow(iIntensity, 3.);\n\n    vec4 samp = texture2D(iFrame, uv);\n    vec3 hsl = rgb2hsv(samp.rgb);\n    hsl.g *= 1.0 - factor;\n    gl_FragColor.rgb = hsv2rgb(hsl);\n    gl_FragColor.a = samp.a;\n}\n", 
    "resources/effects/foh.0.glsl": "// First order (expontential) hold\n\nvoid main(void) {\n    vec4 prev = texture2D(iChannel[0], uv);\n    vec4 next = texture2D(iChannel[1], uv);\n\n/*\n    float t = pow(2, round(6 * iIntensity - 4));\n    float a = 0.98;\n    if (iIntensity < 0.09 || mod(iTime, t) < 0.1)\n        gl_FragColor = next;\n        */\n\n    gl_FragColor = mix(next, prev, pow(iIntensity, 0.4));\n    gl_FragColor = clamp(gl_FragColor, 0, 1);\n}\n", 
    "resources/effects/green.0.glsl": "// Zero out the green channel (green is not a creative color)\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    gl_FragColor.r *= 1. - iIntensity;\n    gl_FragColor.b *= 1. - iIntensity;\n}\n", 
    "resources/effects/test.1.glsl": "void main(void) {\n    vec2 normCoord = 2. * (uv - 0.5) * aspectCorrection;\n    gl_FragColor = vec4(abs(normCoord), 0., 1.);\n}\n", 
    "resources/effects/tile.0.glsl": "// Repeating tiles\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float bins = pow(2, 4. * iIntensity);\n    vec2 newUV = normCoord * bins;\n    newUV = mod(newUV + 1.5, 2.);\n    newUV = abs(newUV - 1.) - 0.5;\n    newUV = newUV / aspectCorrection + 0.5;\n\n    vec4 oc = texture2D(iFrame, (uv - 0.5) * bins + 0.5);\n    vec4 nc = texture2D(iFrame, newUV);\n\n    oc.a *= (1. - smoothstep(0.1, 0.2, iIntensity));\n    nc.a *= smoothstep(0, 0.1, iIntensity);\n\n    gl_FragColor = composite(oc, nc);\n}\n", 
    "resources/effects/wstrobe.0.glsl": "// White strobe to the beat\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    vec4 c;\n\n    float freq;\n    if(iIntensity < 0.05) freq = 0.;\n    else if(iIntensity < 0.25) freq = 4.;\n    else if(iIntensity < 0.45) freq = 2.;\n    else if(iIntensity < 0.65) freq = 1.;\n    else if(iIntensity < 0.85) freq = 0.5;\n    else freq = 0.25;\n\n    if(freq > 0) {\n        vec3 hsv = rgb2hsv(gl_FragColor.rgb);\n        hsv.y = hsv.y * (1. - sawtooth(iTime / freq, 0.1));\n        gl_FragColor.rgb = hsv2rgb(hsv);\n    }\n}\n", 
    "resources/effects/bstrobe.0.glsl": "// Full black strobe. Intensity increases frequency\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    vec4 c;\n\n    float freq;\n    if(iIntensity < 0.05) freq = 0.;\n    else if(iIntensity < 0.15) freq = 4.;\n    else if(iIntensity < 0.25) freq = 2.;\n    else if(iIntensity < 0.35) freq = 1.;\n    else if(iIntensity < 0.45) freq = 0.5;\n    else if(iIntensity < 0.55) freq = 0.25;\n    else if(iIntensity < 0.65) freq = 0.125;\n    else if(iIntensity < 0.75) freq = 0.0625;\n    else freq = 0.03125;\n\n    if(freq > 0) {\n        c = vec4(0., 0., 0., 1. - mod(iTime, freq) / freq);\n        //c.a *= pow(iIntensity, 0.3);\n        gl_FragColor = composite(gl_FragColor, c);\n    }\n}\n", 
    "resources/effects/polar.0.glsl": "// Convert vertical lines to rings\n\nvoid main(void) {\n    vec2 normCoord = 2. * (uv - 0.5) * aspectCorrection;\n\n    vec2 newUV = vec2(length(normCoord) / sqrt(2.), abs(atan(normCoord.x, -normCoord.y) / M_PI)) - 0.5;\n    newUV = newUV / aspectCorrection + 0.5;\n\n    gl_FragColor = texture2D(iFrame, mix(uv, newUV, iIntensity));\n}\n", 
    "resources/effects/black.0.glsl": "// Reduce alpha\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    gl_FragColor.a *= (1. - iIntensity);\n}\n", 
    "resources/effects/allwhite.0.glsl": "// Basic white fill\n\nvoid main(void) {\n    vec4 c = vec4(1., 1., 1., iIntensity);\n    gl_FragColor = composite(texture2D(iFrame, uv), c);\n}\n", 
    "resources/effects/spinb.0.glsl": "// Spins the pattern round to the beat\n\nvoid main(void) {\n    float r;\n    float freq;\n    if(iIntensity < 0.05) freq = 0.;\n    else if(iIntensity < 0.25) freq = 32.;\n    else if(iIntensity < 0.35) freq = 16.;\n    else if(iIntensity < 0.45) freq = 8.;\n    else if(iIntensity < 0.55) freq = 4.;\n    else if(iIntensity < 0.65) freq = 2.;\n    else if(iIntensity < 0.75) freq = 1.;\n    else if(iIntensity < 0.85) freq = 0.5;\n    else freq = 0.25;\n\n    if(freq > 0) {\n        r = mod(iTime, freq) / freq;\n    } else {\n        r = 0; \n    }\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float s = sin(r * M_PI);\n    float c = cos(r * M_PI);\n    mat2 rot = mat2(c, -s, s, c);\n\n    vec2 newUV = normCoord * rot / aspectCorrection;\n    newUV *= min(iResolution.x, iResolution.y) / max(iResolution.x, iResolution.y);\n    newUV += 0.5;\n\n    vec4 oc = texture2D(iFrame, uv);\n    vec4 nc = texture2D(iFrame, newUV);\n    nc.a *= box(newUV);\n\n    gl_FragColor = mix(oc, nc, smoothstep(0, 0.2, iIntensity));\n}\n", 
    "resources/effects/lpf.0.glsl": "// Smooth output\n\nvoid main(void) {\n    vec4 prev = texture2D(iChannel[0], uv);\n    vec4 next = texture2D(iFrame, uv);\n    prev.a *= 0.98;\n    gl_FragColor = mix(next, prev, pow(iIntensity, 0.4));\n}\n", 
    "resources/effects/distort.0.glsl": "// Distort the screen to the beat\n\nvoid main(void) {\n    vec3 noise_input = vec3(uv, iTime * 0.3);\n    vec2 shift = (vec2(noise(noise_input), noise(noise_input + 100.)) - 0.5);\n    shift += (vec2(noise(2. * noise_input), noise(2. * noise_input + 100.)) - 0.5) * 0.5;\n    shift += (vec2(noise(4. * noise_input), noise(4. * noise_input + 100.)) - 0.5) * 0.25;\n    shift = 0.3 * shift;\n    shift /= aspectCorrection;\n\n    gl_FragColor = texture2D(iFrame, uv + shift * iIntensity * (15. * iAudioLevel) * sawtooth(iTime, 0.1));\n}\n", 
    "resources/effects/cyan.0.glsl": "// Cyan diagonal stripes\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float t = normCoord.x * 3.0 + normCoord.y * 3.0;\n    float y = smoothstep(0.2, 0.7, abs(mod(t - 3. * iIntensityIntegral, 2.) - 1.));\n    float g = smoothstep(0.5, 0.9, abs(mod(1. + t - 3. * iIntensityIntegral, 2.) - 1.));\n\n    vec4 c = vec4(0., 1., 1., y);\n    c = composite(c, vec4(0., 0., 1., g * smoothstep(0.5, 0.8, iIntensity)));\n\n    c.a *= smoothstep(0., 0.1, iIntensity);\n    c = clamp(c, 0., 1.);\n    gl_FragColor = composite(gl_FragColor, c);\n}\n", 
    "resources/effects/randy.0.glsl": "// Obnoxiously zoom and rotate\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float theta = 0.3 * (sin(iIntensityIntegral * 0.6) - sin(2 * iIntensityIntegral * 0.6)) * iIntensity;\n    float zoom = 1. + 0.2 * (-1. + sin(iIntensityIntegral * 0.35) - sin(2 * iIntensityIntegral * 0.35)) * iIntensity;\n\n    float s = sin(theta) / zoom;\n    float c = cos(theta) / zoom;\n    mat2 rot = mat2(c, -s, s, c);\n\n    vec2 newUV = normCoord * rot;\n    newUV = newUV / aspectCorrection + 0.5;\n\n    vec4 nc = texture2D(iFrame, newUV);\n    nc.a *= box(newUV);\n\n    gl_FragColor = nc;\n}\n", 
    "resources/effects/test.0.glsl": "#property description A green & red circle in the center\n\nvoid main(void) {\n    gl_FragColor = texture2D(iInput, uv);\n    vec4 c;\n\n    vec2 normCoord = 2. * (uv - 0.5) * aspectCorrection;\n\n    c = vec4(1., 1., 1., 1. - smoothstep(iIntensity - 0.1, iIntensity, length(normCoord)));\n    gl_FragColor = composite(gl_FragColor, c);\n\n    c = texture2D(iChannel[1], (uv - 0.5) / iIntensity + 0.5);\n    c.a = 1. - smoothstep(iIntensity - 0.2, iIntensity - 0.1, length(normCoord));\n    gl_FragColor = composite(gl_FragColor, c);\n}\n\n#buffershader\n\nvoid main(void) {\n    vec2 normCoord = 2. * (uv - 0.5) * aspectCorrection;\n    gl_FragColor = vec4(abs(normCoord), 0., 1.);\n}\n", 
    "resources/glsl/plain_vertex.glsl": "attribute vec4 vPosition;\nvarying highp vec2 uv;\nvoid main() {\n    gl_Position = vec4(vPosition.xy, 1., 1.);\n    uv = vPosition.zw;\n}\n", 
    "resources/effects/polygon.0.glsl": "// Convert vertical lines to polygon rings\n\nvoid main(void) {\n    vec2 xy = gl_FragCoord.xy / iResolution;\n    vec2 xy_cent = 2. * xy - 1.;\n    float angle = abs(atan(xy_cent.y, xy_cent.x));\n    float n_sides = (iIntensity * 5.) + 1.;\n    float arc = 2. * M_PI / n_sides;\n    float a1 = mod(angle, arc);\n    float corr = cos(a1 - arc / 2.) / (sqrt(2.) * cos(arc / 2.));\n\n    vec2 rtheta = vec2(length(xy_cent) * corr, 0.5 + angle / (2. * M_PI));\n    vec2 uv = mix(xy, rtheta, clamp(iIntensity * 5., 0., 1.));\n\n    gl_FragColor = texture2D(iFrame, uv);\n}\n", 
    "resources/effects/edge.0.glsl": "// From https://www.shadertoy.com/view/XssGD7\n\nvoid main()\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// Sobel operator\n\tfloat offset = onePixel;\n\tvec3 o = vec3(-offset, 0.0, offset);\n\tvec4 gx = vec4(0.0);\n\tvec4 gy = vec4(0.0);\n\tvec4 t;\n\tgx += texture2D(iFrame, uv + o.xz);\n\tgy += gx;\n\tgx += 2.0*texture2D(iFrame, uv + o.xy);\n\tt = texture2D(iFrame, uv + o.xx);\n\tgx += t;\n\tgy -= t;\n\tgy += 2.0*texture2D(iFrame, uv + o.yz);\n\tgy -= 2.0*texture2D(iFrame, uv + o.yx);\n\tt = texture2D(iFrame, uv + o.zz);\n\tgx -= t;\n\tgy += t;\n\tgx -= 2.0*texture2D(iFrame, uv + o.zy);\n\tt = texture2D(iFrame, uv + o.zx);\n\tgx -= t;\n\tgy -= t;\n\tvec4 grad = sqrt(gx * gx + gy * gy);\n\n    vec4 original = texture2D(iFrame, uv);\n    grad.a *= smoothstep(0., 0.5, iIntensity);\n    original.a *= 1. - smoothstep(0.5, 1., iIntensity);\n\n    gl_FragColor = composite(original, grad);\n}\n", 
    "resources/effects/fire.0.glsl": "// Fire from the bottom\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    vec3 noise_input = vec3(normCoord * 3. + vec2(0., -iTime * 0.5), iTime * 0.3);\n    vec2 shift = (vec2(noise(noise_input), noise(noise_input + 100.)) - 0.5);\n    shift += (vec2(noise(2. * noise_input), noise(2. * noise_input + 100.)) - 0.5) * 0.5;\n    shift += (vec2(noise(4. * noise_input), noise(4. * noise_input + 100.)) - 0.5) * 0.25;\n    shift = (iIntensity * 0.5 + 0.5) * shift + vec2(0., 0.5 - 0.5 * iIntensity);\n    shift /= aspectCorrection;\n\n    uv = uv + shift;\n    vec4 color = vec4(1., uv.y * 0.6, 0., smoothstep(0.1, 0.3, (1. - uv.y)));\n    \n    color.a *= smoothstep(0., 0.2, iIntensity);\n    \n    gl_FragColor = composite(gl_FragColor, color);\n}\n", 
    "resources/effects/heart.0.glsl": "// Pink heart\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n\n    // heart from shadertoy\n    vec2 normCoord = (uv - 0.5) * aspectCorrection + vec2(0., -0.15);\n    normCoord *= 2. / iIntensity;\n    float a = atan(normCoord.x, normCoord.y) / M_PI;\n    float r = length(normCoord);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n    vec4 c = vec4(1., 0.5, 0.5, 1. - smoothstep(0, 3. * onePixel, r - d));\n    gl_FragColor = composite(gl_FragColor, c);\n}\n", 
    "resources/effects/diodelpf.0.glsl": "// Apply smoothing over time with new hits happening instantly\n\nvoid main(void) {\n    vec4 prev = texture2D(iChannel[0], uv);\n    vec4 next = texture2D(iFrame, uv);\n    gl_FragColor.rgb = next.rgb;\n    if (next.a > prev.a) {\n        gl_FragColor = next;\n    } else {\n        prev.a *= pow(iIntensity, 0.1);\n        gl_FragColor = composite(next, prev);\n    }\n    gl_FragColor.a = clamp(gl_FragColor.a, 0, 1);\n    \n}\n", 
    "resources/effects/slide.0.glsl": "// Slide the screen left-to-right\n\nvoid main(void) {\n    float deviation = iIntensityIntegral;\n    vec2 uv2 = (uv - 0.5) * aspectCorrection;\n    uv2.x = abs(mod(uv2.x + deviation + 1.5, 2.) - 1.) - 0.5;\n    uv2  = uv2 / aspectCorrection + 0.5;\n\n    vec4 oc = texture2D(iFrame, uv);\n    vec4 c = texture2D(iFrame, uv2);\n\n    oc.a *= (1. - smoothstep(0.1, 0.2, iIntensity));\n    c.a *= smoothstep(0, 0.1, iIntensity);\n\n    gl_FragColor = composite(oc, c);\n}\n", 
    "resources/effects/starfield.0.glsl": "// Pixels radiating from the center\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    vec4 c = texture2D(iChannel[1], uv);\n    c.a *= smoothstep(0., 0.2, iIntensity);\n    gl_FragColor = composite(gl_FragColor, c);\n}\n", 
    "resources/effects/resat.0.glsl": "// Recolor output with noise rainbow\n\nvoid main(void) {\n    float factor = pow(iIntensity, 0.6);\n    vec3 noise_input = vec3(uv, iTime / 8.);\n    float n = noise(noise_input) - 0.1;\n    n += (noise(2. * noise_input) - 0.5) * 0.5;\n    n += (noise(4. * noise_input) - 0.5) * 0.25;\n    //n = mod(n + 0.5, 1.0);\n    //n = mod(n + hsl.r, 1.0);\n\n    vec4 samp = texture2D(iFrame, uv);\n    vec3 hsl = rgb2hsv(samp.rgb);\n    hsl.g = 1.0 - (1.0 - hsl.g) * (1.0 - factor);\n    //hsl.r = mix(hsl.r, n, iIntensity);\n    hsl.r = mod(hsl.r + n * iIntensity, 1.0);\n    gl_FragColor.rgb = hsv2rgb(hsl);\n    gl_FragColor.a = samp.a;\n}\n", 
    "resources/effects/rotate.0.glsl": "// Rotate the screen\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float r = iIntensity;\n    float s = sin(r * M_PI);\n    float c = cos(r * M_PI);\n    mat2 rot = mat2(c, -s, s, c);\n\n    vec2 newUV = normCoord * rot / aspectCorrection + 0.5;\n\n    gl_FragColor = texture2D(iFrame, newUV);\n    gl_FragColor.a *= box(newUV);\n}\n", 
    "resources/effects/foh.1.glsl": "void main(void) {\n    float t = pow(2, round(6 * iIntensity - 4));\n    float a = 0.98;\n    if (iIntensity < 0.09 || mod(iTime, t) < 0.1)\n        gl_FragColor = texture2D(iFrame, uv);\n    else\n        gl_FragColor = texture2D(iChannel[1], uv);\n}\n", 
    "resources/effects/dwwave.0.glsl": "// Diagonal white wave\n\nvoid main(void) {\n    float xpos = iIntensityIntegral * 1.5;\n    float xfreq = (iIntensity + 0.5) * 2.;\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float x = mod((normCoord.x + normCoord.y) * 0.5 * xfreq + xpos, 1.);\n    gl_FragColor = texture2D(iFrame, uv);\n    gl_FragColor = composite(gl_FragColor, vec4(1., 1., 1., step(x, 0.3) * smoothstep(0., 0.5, iIntensity)));\n}\n", 
    "resources/effects/desatb.0.glsl": "// Desaturate to the beat\n\nvoid main(void) {\n    float t = mod(iTime, 4.0) / 4.0;\n    float factor = pow(iIntensity * t, 2.5);\n\n    vec4 samp = texture2D(iFrame, uv);\n    vec3 hsl = rgb2hsv(samp.rgb);\n    hsl.g *= 1.0 - factor;\n    gl_FragColor.rgb = hsv2rgb(hsl);\n    gl_FragColor.a = samp.a;\n}\n", 
    "resources/effects/spin.0.glsl": "// Rotate the screen\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float r = iIntensityIntegral * 0.6;\n    float s = sin(r * M_PI);\n    float c = cos(r * M_PI);\n    mat2 rot = mat2(c, -s, s, c);\n\n    vec2 newUV = normCoord * rot / aspectCorrection;\n    newUV *= min(iResolution.x, iResolution.y) / max(iResolution.x, iResolution.y) * sqrt(0.5);\n    newUV += 0.5;\n\n    vec4 oc = texture2D(iFrame, uv);\n    vec4 nc = texture2D(iFrame, newUV);\n    nc.a *= box(newUV);\n\n    gl_FragColor = mix(oc, nc, smoothstep(0, 0.2, iIntensity));\n}\n", 
    "resources/effects/inception.0.glsl": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Modified for Radiance by Eric Van Albert\n\n#define MAX_DEPTH 12\n\nvec4 lookup(vec2 coord) {\n    return texture2D(iFrame, coord / aspectCorrection + 0.5);\n}\n\nvoid main() {\n    float depth = iIntensity * MAX_DEPTH;\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2  d = -normCoord / depth;\n    float w = 3. / depth;\n    vec2  s = normCoord;\n    vec4 col = lookup(s);\n    for( int i=0; i<int(depth); i++ )\n    {\n        w *= .99;\n        s += d;\n        vec4 res = lookup(s);\n        //res = smoothstep(0., 1., res); // Makes colors more vibrant\n        res.a *= w;\n        res.a *= max(res.r, max(res.g, res.b));\n        col = composite(col, res);\n    }\n\n\tgl_FragColor = col;\n}\n", 
    "resources/effects/swipe.0.glsl": "// Only update a vertical slice that slides across\n\nvoid main(void) {\n    vec4 prev = texture2D(iChannel[0], uv);\n    vec4 next = texture2D(iFrame, uv);\n    float factor = pow(iIntensity, 2.0);\n\n    float t = mod(iTime / 4.0 - uv.x, 1.0);\n    float x = 0.0;\n    if (t < 0.5) x = pow(0.5 - t, 3.0);\n\n    factor = min(factor, 1.0 - x);\n    factor = clamp(factor, 0.0, 1.0);\n\n    gl_FragColor = mix(next, prev, factor);\n}\n", 
    "resources/effects/smoke.0.glsl": "// Perlin noise green smoke\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    vec3 noise_input = vec3(normCoord * iIntensity * 4, iIntensity + iIntensityIntegral * 0.1);\n    float n = noise(noise_input) - 0.1;\n    n += (noise(2. * noise_input) - 0.5) * 0.5;\n    n += (noise(4. * noise_input) - 0.5) * 0.25;\n    n += (noise(8. * noise_input) - 0.5) * 0.125;\n    n += (noise(16. * noise_input) - 0.5) * 0.0625;\n    n = n / 3.;\n\n    float a = clamp(n * n * 5., 0., 1.) * smoothstep(0., 0.2, iIntensity);\n\n    gl_FragColor = texture2D(iFrame, uv);\n    gl_FragColor = composite(gl_FragColor, vec4(0., 1., 0., a));\n}\n", 
    "resources/effects/bwave.0.glsl": "// Black sine wave from left to right.\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float x = (normCoord.x + normCoord.y) * 15. + iTime;\n    gl_FragColor = texture2D(iFrame, uv);\n    gl_FragColor.a *= 1.0 - iIntensity * (0.5 * sin(x) + 0.5);\n}\n", 
    "resources/effects/sscansquare.0.glsl": "// White slit for testing\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float x = iIntensity;\n    vec4 color = vec4(1.0, 1.0, 1.0, 1. - step(0.5 * onePixel, abs(x - 0.5 - normCoord)));\n    gl_FragColor = texture2D(iFrame, uv);\n    gl_FragColor = composite(gl_FragColor, color);\n}\n", 
    "resources/effects/rblur.0.glsl": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Modified for Radiance by Eric Van Albert\n\n#define DEPTH 64\n\nvec4 lookup(vec2 coord) {\n    return texture2D(iFrame, coord / aspectCorrection + 0.5);\n}\n\nvoid main() {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2  d = -normCoord / DEPTH.;\n    float w = iIntensity * 4. / DEPTH.;\n    vec2  s = normCoord;\n    vec4 col = lookup(s);\n    for( int i=0; i<DEPTH; i++ )\n    {\n        w *= .99;\n        s += d;\n        vec4 res = lookup(s);\n        //res = smoothstep(0., 1., res); // Makes colors more vibrant\n        res.a *= w;\n        res.a *= max(res.r, max(res.g, res.b));\n        col = composite(col, res);\n    }\n\n\tgl_FragColor = col;\n}\n", 
    "resources/effects/strobe.0.glsl": "// Strobe alpha to the beat\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    vec4 c;\n\n    float freq;\n    if(iIntensity < 0.05) freq = 0.;\n    else if(iIntensity < 0.45) freq = 2.;\n    else freq = 1.;\n\n    if(freq > 0) {\n        gl_FragColor.a *= 1. - ((1. - sawtooth(iTime / freq, 0.2)) * iIntensity* min(3. * iAudioLevel, 1.));\n    }\n}\n", 
    "resources/effects/qcircle.0.glsl": "// Big purple soft circle \n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float t = iTime / 4.0;\n    vec2 center = vec2(sin(t), cos(t));\n    center *= 0.5;\n\n    vec4 c = vec4(0.2, 0.1, 0.5, 1.);\n    c.a = clamp(length(center - normCoord), 0, 1);\n    c.a = pow(c.a, 2);\n    c.a = 1.0 - c.a;\n    c.a *= iIntensity;\n\n    gl_FragColor = composite(texture2D(iFrame, uv), c);\n}\n", 
    "resources/glsl/effect_header.glsl": "precision mediump float;\n\n// Time, measured in beats. Wraps around to 0 every 16 beats, [0.0, 16.0)\nuniform highp float iStep;\nuniform highp float iTime;\n\n// Audio levels, high/mid/low/level, [0.0, 1.0]\nuniform vec4  iAudio;\n#define iAudioLow   iAudio.x\n#define iAudioMid   iAudio.y\n#define iAudioHi    iAudio.z\n#define iAudioLevel iAudio.w\n//uniform float iAudioHi;\n//uniform float iAudioLow;\n//uniform float iAudioMid;\n//uniform float iAudioLevel;\n\n// Resolution of the output pattern\nuniform vec2 iResolution;\n\n// Intensity slider, [0.0, 1.0]\nuniform lowp float iIntensity;\n\n// Intensity slider integrated with respect to wall time mod 1024, [0.0, 1024.0)\nuniform float iIntensityIntegral;\n\n// (Ideal) output rate in frames per second\nuniform float iFPS;\n\n// Output of the previous pattern\nuniform sampler2D iInputs[4];\n#define iInput iInputs[0]\n\n// Full frame RGBA noise\nuniform sampler2D iNoise;\n\n// Previous outputs of the other buffershaders\nuniform sampler2D iChannel[4];\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat lin_step(float v) {\n    return v * iStep * iFPS;\n}\nfloat exp_step(float v) {\n    return pow(v, iStep * iFPS);\n}\n// Utilities to convert from an RGB vec3 to an HSV vec3\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Alpha-compsite two colors, putting one on top of the other\nvec4 composite(vec4 under, vec4 over) {\n    float a_out = 1. - (1. - over.a) * (1. - under.a);\n    return clamp(vec4((over.rgb * over.a  + under.rgb * under.a * (1. - over.a)) / a_out, a_out), vec4(0.), vec4(1.));\n}\n\n// Sawtooth wave\nfloat sawtooth(float x, float t_up) {\n    x = mod(x + t_up, 1.);\n    return x / t_up * step(x, t_up) +\n           (1. - x) / (1. - t_up) * (1. - step(x, t_up));\n}\n\n// Box from [0, 0] to (1, 1)\nfloat box(vec2 p) {\n    vec2 b = step(0., p) - step(1., p);\n    return b.x * b.y;\n}\n\n// Predictable randomness\nfloat rand(float c){\n    return fract(sin(c * 12.9898) * 43758.5453);\n}\n\nfloat rand(vec2 c){\n    return fract(sin(dot(c, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 c){\n    return fract(sin(dot(c, vec3(12.9898,78.233, 52.942))) * 43758.5453);\n}\n\nfloat rand(vec4 c){\n    return fract(sin(dot(c, vec4(12.9898, 78.233, 52.942, 35.291))) * 43758.5453);\n}\n\nfloat noise(float p) {\n    float i = floor(p);\n    float x = mod(p, 1.);\n    // x = .5*(1.-cos(M_PI*x));\n    x = 3.*x*x-2.*x*x*x;\n    float a = rand(i+0.);\n    float b = rand(i+1.);\n    return mix(a, b, x);\n}\n\nfloat noise(vec2 p) {\n    vec2 ij = floor(p);\n    vec2 xy = mod(p, 1.);\n    // xy = .5*(1.-cos(M_PI*xy));\n    xy = 3.*xy*xy-2.*xy*xy*xy;\n    float a = rand((ij+vec2(0.,0.)));\n    float b = rand((ij+vec2(1.,0.)));\n    float c = rand((ij+vec2(0.,1.)));\n    float d = rand((ij+vec2(1.,1.)));\n    float x1 = mix(a, b, xy.x);\n    float x2 = mix(c, d, xy.x);\n    return mix(x1, x2, xy.y);\n}\n\nfloat noise(vec3 p) {\n    vec3 ijk = floor(p);\n    vec3 xyz = mod(p, 1.);\n    // xyz = .5*(1.-cos(M_PI*xyz));\n    xyz = 3.*xyz*xyz-2.*xyz*xyz*xyz;\n    float a = rand((ijk+vec3(0.,0.,0.)));\n    float b = rand((ijk+vec3(1.,0.,0.)));\n    float c = rand((ijk+vec3(0.,1.,0.)));\n    float d = rand((ijk+vec3(1.,1.,0.)));\n    float e = rand((ijk+vec3(0.,0.,1.)));\n    float f = rand((ijk+vec3(1.,0.,1.)));\n    float g = rand((ijk+vec3(0.,1.,1.)));\n    float h = rand((ijk+vec3(1.,1.,1.)));\n    float x1 = mix(a, b, xyz.x);\n    float x2 = mix(c, d, xyz.x);\n    float y1 = mix(x1, x2, xyz.y);\n    float x3 = mix(e, f, xyz.x);\n    float x4 = mix(g, h, xyz.x);\n    float y2 = mix(x3, x4, xyz.y);\n    return mix(y1, y2, xyz.z);\n}\n\nfloat noise(vec4 p) {\n    vec4 ijkl = floor(p);\n    vec4 xyzw = mod(p, 1.);\n    // xyz = .5*(1.-cos(M_PI*xyz));\n    xyzw = 3.*xyzw*xyzw-2.*xyzw*xyzw*xyzw;\n    float a = rand((ijkl+vec4(0.,0.,0.,0.)));\n    float b = rand((ijkl+vec4(1.,0.,0.,0.)));\n    float c = rand((ijkl+vec4(0.,1.,0.,0.)));\n    float d = rand((ijkl+vec4(1.,1.,0.,0.)));\n    float e = rand((ijkl+vec4(0.,0.,1.,0.)));\n    float f = rand((ijkl+vec4(1.,0.,1.,0.)));\n    float g = rand((ijkl+vec4(0.,1.,1.,0.)));\n    float h = rand((ijkl+vec4(1.,1.,1.,0.)));\n    float i = rand((ijkl+vec4(0.,0.,0.,1.)));\n    float j = rand((ijkl+vec4(1.,0.,0.,1.)));\n    float k = rand((ijkl+vec4(0.,1.,0.,1.)));\n    float l = rand((ijkl+vec4(1.,1.,0.,1.)));\n    float m = rand((ijkl+vec4(0.,0.,1.,1.)));\n    float n = rand((ijkl+vec4(1.,0.,1.,1.)));\n    float o = rand((ijkl+vec4(0.,1.,1.,1.)));\n    float q = rand((ijkl+vec4(1.,1.,1.,1.)));\n    float x1 = mix(a, b, xyzw.x);\n    float x2 = mix(c, d, xyzw.x);\n    float y1 = mix(x1, x2, xyzw.y);\n    float x3 = mix(e, f, xyzw.x);\n    float x4 = mix(g, h, xyzw.x);\n    float y2 = mix(x3, x4, xyzw.y);\n    float z1 = mix(y1, y2, xyzw.z);\n\n    float x5 = mix(i, j, xyzw.x);\n    float x6 = mix(k, l, xyzw.x);\n    float y3 = mix(x5, x6, xyzw.y);\n    float x7 = mix(m, n, xyzw.x);\n    float x8 = mix(o, q, xyzw.x);\n    float y4 = mix(x7, x8, xyzw.y);\n    float z2 = mix(y3, y4, xyzw.z);\n    return mix(z1, z2, xyzw.w);\n}\n\nfloat onePixel = 1. / min(iResolution.x, iResolution.y);\nvec2 aspectCorrection = iResolution / min(iResolution.x, iResolution.y);\n//vec2 uv = gl_FragCoord.xy / iResolution;\n//#define uv (gl_FragCoord.xy / iResolution)\nvarying highp vec2 uv;\n\n#line 0\n", 
    "resources/effects/yellow.0.glsl": "// Yellow and green vertical waves\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    gl_FragColor = texture2D(iFrame, uv);\n\n    float y = smoothstep(0.2, 0.7, abs(mod(normCoord.x * 4. - iIntensityIntegral, 2.) - 1.));\n    float g = smoothstep(0.5, 0.9, abs(mod(1. + normCoord.x * 4. - iIntensityIntegral, 2.) - 1.));\n\n    vec4 c = vec4(1., 1., 0., y);\n    c = composite(c, vec4(0., 1., 0., g * smoothstep(0.5, 0.8, iIntensity)));\n\n    c.a *= smoothstep(0., 0.1, iIntensity);\n    c = clamp(c, 0., 1.);\n    gl_FragColor = composite(gl_FragColor, c);\n}\n", 
    "resources/effects/tunnel.0.glsl": "// From https://www.shadertoy.com/view/4sXSzs\n\nvoid main()\n{\n\tvec2 q = (uv - vec2(0.5, 0.5)) * aspectCorrection;\n\n    float t2 = iTime * 0.2;\n    vec2 offset = vec2(sin(t2), cos(t2)) * 0.2;\n    q -= offset;\n\n\tfloat len = length(q);\n\n    float t = iIntensityIntegral * 3.;\n\tfloat a = 6. * atan(q.y, q.x) / (2. * M_PI) + t * 0.3;\n\tfloat b = 6. * atan(q.y, q.x) / (2. * M_PI) + t * 0.3;\n\tfloat r1 = 0.3 / len + t * 0.5;\n\tfloat r2 = 0.2 / len + t * 0.5;\n\n    vec2 texcoords = vec2(a + 0.1 / len, r1);\n\tvec4 tex1 = texture2D(iFrame, abs(mod(texcoords, 2.) - 1.));\n\tvec4 c = vec4(tex1.rgb, tex1.a * smoothstep(0., 0.1, len));\n\n    c.a *= smoothstep(0.1, 0.2, iIntensity);\n\n    vec2 texcoords2 = (uv - 0.5 - offset) / (1. - smoothstep(0., 0.2, iIntensity)) + 0.5 + offset;\n    vec4 c2 = texture2D(iFrame, texcoords2);\n    c2.a *= box(texcoords2);\n\n    gl_FragColor = composite(c2, c);\n}\n\n", 
    "resources/effects/fireball.0.glsl": "// Fileball in the center\n\nvoid main(void) {\n    vec2 uv = gl_FragCoord.xy / iResolution;\n    gl_FragColor = texture2D(iFrame, uv);\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    vec3 noise_input = vec3(length(normCoord) * 3. - iTime, abs(atan(normCoord.y, normCoord.x)), iTime * 0.3);\n    vec2 shift = (vec2(noise(noise_input), noise(noise_input + 100.)) - 0.5);\n    shift += (vec2(noise(2. * noise_input), noise(2. * noise_input + 100.)) - 0.5) * 0.5;\n    shift += (vec2(noise(4. * noise_input), noise(4. * noise_input + 100.)) - 0.5) * 0.25;\n    shift = (iIntensity * 0.7 + 0.3) * shift;\n\n    normCoord = normCoord + shift;\n    vec4 color = vec4(1., length(normCoord) * 2., 0., smoothstep(0.4, 0.5, (1. - length(normCoord))));\n    \n    color.a *= smoothstep(0., 0.2, iIntensity);\n    \n    gl_FragColor = composite(gl_FragColor, color);\n}\n", 
    "resources/effects/bounce.0.glsl": "// Zoom in (bounce) to the beat & audio\n\nvoid main(void) {\n    float factor = 1. - 3. * iIntensity * iAudioLevel * sawtooth(iTime, 0.1);\n    factor = clamp(0.05, 2., factor);\n\n    gl_FragColor = texture2D(iFrame, (uv - 0.5) * factor + 0.5);\n}\n", 
    "resources/effects/speckle.0.glsl": "// Per-pixel twinkle effect\n\nvoid main(void) {\n    gl_FragColor = texture2D(iChannel[0], uv);\n    gl_FragColor.a *= exp(-iIntensity / 20.);\n    if (rand(vec3(uv, iTime)) < exp(-iIntensity * 4.)) {\n        gl_FragColor = texture2D(iFrame, uv);\n    }\n}\n", 
    "resources/effects/oscope.0.glsl": "void main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float x = normCoord.x;\n    float wave = 0;\n    wave += 0.6 * sin(x * 10. + iTime * 1.) * iAudioLow;\n    wave += 0.6 * sin(x * 15. + iTime * -0.3) * iAudioLow;\n    wave += 0.2 * sin(x * 40. + iTime * 8.) * iAudioMid;\n    wave += 0.2 * sin(x * 70. + iTime * -3.) * iAudioLow;\n    wave += 0.1 * sin(x * 120. + iTime * 16.) * iAudioHi;\n    wave += 0.1 * sin(x * 180. + iTime * -10.) * iAudioHi;\n    wave *= iAudioLevel;\n    wave *= smoothstep(0., 0.3, iIntensity);\n\n    float d = abs(normCoord.y - wave);\n\n    float glow = 1. - smoothstep(0, (0.02 + iAudioHi * 0.3) * smoothstep(0., 0.5, iIntensity), d);\n    glow += 0.5 * (1. - smoothstep(0, (0.3 + iAudioHi * 0.3) * iIntensity, d));\n    vec4 c = vec4(0., 1., 0., glow);\n    gl_FragColor = composite(gl_FragColor, c);\n}\n\n", 
    "resources/effects/chansep.0.glsl": "// Red / green / blue color channel separation\n// AKA \"Chromatic Aberration\"\n\nvoid main(void) {\n    float spin = iTime * 0.2;\n    float separate = iIntensity * 0.1 * cos(iTime * M_PI * 0.25);\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2 redOffset = normCoord - separate * vec2(cos(spin), sin(spin));\n    vec2 greenOffset = normCoord - separate * vec2(cos(2. + spin), sin(2. + spin));\n    vec2 blueOffset = normCoord - separate * vec2(cos(4. + spin), sin(4. + spin));\n\n    vec4 redImage = texture2D(iFrame, redOffset / aspectCorrection + 0.5);\n    vec4 greenImage = texture2D(iFrame, greenOffset / aspectCorrection + 0.5);\n    vec4 blueImage = texture2D(iFrame, blueOffset / aspectCorrection + 0.5);\n\n    vec3 rgb = vec3(redImage.r * redImage.a, greenImage.g * greenImage.a, blueImage.b * blueImage.a);\n    float a_out = 1. - (1. - rgb.r) * (1. - rgb.g) * (1. - rgb.b);\n    gl_FragColor = vec4(rgb / a_out, a_out);\n}\n", 
    "resources/effects/red.0.glsl": "// Change the color (in HSV) to red\n\nvoid main(void) {\n    vec4 c = texture2D(iFrame, uv);\n    gl_FragColor.r = mix(c.r, (c.r + c.g + c.b) / 3., iIntensity);\n    gl_FragColor.g = c.g * (1. - iIntensity);\n    gl_FragColor.b = c.b * (1. - iIntensity);\n    gl_FragColor.a = c.a;\n}\n", 
    "resources/effects/wwave.0.glsl": "// White wave with hard edges\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    float xpos = iIntensityIntegral * 1.5;\n    float xfreq = (iIntensity + 0.5) * 2.;\n    float x = mod(normCoord.x * xfreq + xpos, 1.);\n    gl_FragColor = texture2D(iFrame, uv);\n    gl_FragColor = composite(gl_FragColor, vec4(1., 1., 1., step(x, 0.3) * smoothstep(0., 0.5, iIntensity)));\n}\n", 
    "resources/effects/flow.1.glsl": "void main(void) {\n\n    gl_FragColor = texture2D(iChannel[1], (uv - 0.5) * 0.98 + 0.5);\n    gl_FragColor.a *= exp((iIntensity - 2.) / 50.) * smoothstep(0, 0.01, length((uv - 0.5) * aspectCorrection));\n\n    vec4 c = texture2D(iFrame, uv);\n    float s = smoothstep(0.90, 1., 1. - mod(iTime, 1.)) * iAudioLevel;\n    c.a *=  min(3. * s, 1.);\n    gl_FragColor = composite(gl_FragColor, c);\n}\n", 
    "resources/effects/pixelate.0.glsl": "// Pixelate/quantize the output\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    float bins = 256. * pow(2, -9. * iIntensity);\n\n    normCoord = round(normCoord * bins) / bins;\n\n    vec2 newUV = normCoord / aspectCorrection + 0.5;\n\n    gl_FragColor = texture2D(iFrame, newUV);\n}\n", 
    "resources/effects/posterize.0.glsl": "// Reduce number of colors\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n\n    //float bins = 256. * pow(2, -8. * iIntensity);\n    float bins = min(256., 1. / iIntensity);\n\n    gl_FragColor = round(gl_FragColor * bins) / bins;\n}\n", 
    "resources/effects/gstrobe.0.glsl": "// Strobe alpha to the beat\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    vec4 c;\n\n    float freq;\n    if(iIntensity < 0.05) freq = 0.;\n    else if(iIntensity < 0.45) freq = 2.;\n    else freq = 1.;\n\n    if(freq > 0) {\n        float i = (1. - sawtooth(iTime / freq, 0.1)) * min(3. * iAudioLevel, 1.);\n        gl_FragColor.r *= i;\n        gl_FragColor.b *= i;\n        gl_FragColor.g *= 1. - i;\n    }\n}\n", 
    "resources/effects/wave.0.glsl": "// Green and blue base pattern\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec4 c = vec4(0., 0., 0., 1.);\n    float ratio = 15;\n    c.r = 0.0;\n    c.g = 0.5 * sin((normCoord.x + normCoord.y) * ratio) + 0.5;\n    c.b = 0.5 * sin((normCoord.x - normCoord.y) * ratio) + 0.5;\n    c.a = iIntensity;\n\n    gl_FragColor = composite(texture2D(iFrame, uv), c);\n}\n", 
    "resources/effects/depolar.0.glsl": "// Convert rings to vertical lines\n\nvoid main(void) {\n    vec2 xy = gl_FragCoord.xy / iResolution;\n    float angle  = xy.y * M_PI * 1.0;\n    vec2 rtheta = xy.x * sqrt(2.) * vec2(sin(angle), -cos(angle));\n    rtheta = (rtheta + 1.) / 2.;\n\n    vec2 uv = mix(xy, rtheta, iIntensity);\n\n    gl_FragColor = texture2D(iFrame, uv);\n}\n", 
    "resources/effects/rjump.0.glsl": "// Shift the hue on the beat\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    \n    float t;\n    if (iIntensity < 0.85)\n        t = iTime / 4.0;\n    else if (iIntensity < 0.95)\n        t = iTime / 2.0;\n    else\n        t = iTime;\n\n    float deviation = mod(3. * floor(t), 8.) / 8.;\n    deviation *= clamp(iIntensity / 0.8, 0., 1.);\n\n    vec3 hsv = rgb2hsv(gl_FragColor.rgb);\n    hsv.r = mod(hsv.r + 1. + deviation, 1.);\n    gl_FragColor.rgb = hsv2rgb(hsv);\n}\n", 
    "resources/glsl/plain_fragment.glsl": "varying highp vec2 uv;\nuniform sampler2D iTexture;\nvoid main() {\n    gl_FragColor = texture2D(iTexture, uv);\n}\n", 
    "resources/effects/vu.0.glsl": "// Blue vertical VU meter\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    vec3 audio = vec3(iAudioLow, iAudioMid, iAudioHi);\n\n    audio = audio * 2. * iIntensity;\n\n    vec3 draw = 1. - smoothstep(audio - onePixel, audio, vec3(abs(normCoord.x)));\n\n    vec4 c = composite(composite(vec4(0., 0., 0.5, draw.x), vec4(0., 0., 1., draw.y)), vec4(0.3, 0.3, 1., draw.z));\n    c = clamp(c, 0., 1.);\n    gl_FragColor = composite(gl_FragColor, c);\n}\n", 
    "resources/effects/zoh.0.glsl": "// Zero order hold to the beat\n\nvoid main(void) {\n    vec4 prev = texture2D(iChannel[0], uv);\n    vec4 next = texture2D(iFrame, uv);\n\n    float t = pow(2, round(6 * iIntensity - 4));\n    float a = 1;\n\n    if (iIntensity < 0.09)\n        a = 0;\n    else if (mod(iTime, t) < 0.1)\n        a = 0;\n\n    gl_FragColor = mix(next, prev, a);\n}\n", 
    "resources/effects/flow.0.glsl": "// Radiate color from the center based on audio\n\nvoid main(void) {\n    vec2 uv = gl_FragCoord.xy / iResolution;\n\n    gl_FragColor = texture2D(iFrame, uv);\n    vec4 c = texture2D(iChannel[1], uv);\n    c.a *= smoothstep(0., 0.2, iIntensity);\n    gl_FragColor = composite(c, gl_FragColor);\n}\n", 
    "resources/effects/rblurb.0.glsl": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Modified for Radiance by Eric Van Albert\n\n#define DEPTH 64\n\nvec4 lookup(vec2 coord) {\n    return texture2D(iFrame, coord / aspectCorrection + 0.5);\n}\n\nvoid main() {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2  d = -normCoord / DEPTH.;\n    float w = iIntensity * iAudioLow * 7. / DEPTH.;\n    vec2  s = normCoord;\n    vec4 col = lookup(s);\n    for( int i=0; i<DEPTH; i++ )\n    {\n        w *= .99;\n        s += d;\n        vec4 res = lookup(s);\n        //res = smoothstep(0., 1., res); // Makes colors more vibrant\n        res.a *= w;\n        res.a *= max(res.r, max(res.g, res.b));\n        col = composite(col, res);\n    }\n\n\tgl_FragColor = col;\n}\n", 
    "resources/effects/snowcrash.0.glsl": "// Snowcrash: white static noise\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    float x = rand(vec3(gl_FragCoord.xy, iTime));\n    vec4 c = vec4(x, x, x, 1.0);\n    gl_FragColor = mix(gl_FragColor, c, iIntensity);\n}\n", 
    "resources/effects/interstellar.0.glsl": "// From https://www.shadertoy.com/view/Xdl3D2\n\nconst float tau = 6.28318530717958647692;\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\nvec4 Noise( in ivec2 x )\n{\n\treturn 2. * texture2D(iNoise, (vec2(x)+0.5)/256.0, -100.);\n}\n\nvoid main()\n{\n\tvec3 ray;\n\tray.xy = 2.0*(gl_FragCoord.xy-iResolution.xy*.5)/iResolution.x;\n\tray.z = 1.0;\n\n\t//float offset = iTime*.5;\t\n\t//float speed2 = (cos(offset)+1.0)*2.0;\n\tfloat offset = iIntensityIntegral * 0.5;\t\n\tfloat speed2 = 3. * iAudioLow;\n\tfloat speed = speed2+.1;\n\t//offset += sin(offset)*.96;\n\t//offset *= 2.0;\n\t\n\t\n\tvec3 col = vec3(0);\n\t\n\tvec3 stp = ray/max(abs(ray.x),abs(ray.y));\n\t\n\tvec3 pos = 2.0*stp+.5;\n\tfor ( int i=0; i < 20; i++ )\n\t{\n\t\tfloat z = Noise(ivec2(pos.xy)).x;\n\t\tz = fract(z-offset);\n\t\tfloat d = 50.0*z-pos.z;\n\t\tfloat w = pow(max(0.0,1.0-8.0*length(fract(pos.xy)-.5)),2.0);\n\t\tvec3 c = max(vec3(0),vec3(1.0-abs(d+speed2*.5)/speed,1.0-abs(d)/speed,1.0-abs(d-speed2*.5)/speed));\n\t\tcol += 1.5*(1.0-z)*c*w;\n\t\tpos += stp;\n\t}\n\t\n\tvec3 fragColor = ToGamma(col);\n    float v = max(max(fragColor.r, fragColor.g), fragColor.b);\n    vec4 c = texture2D(iFrame, uv);\n    gl_FragColor = composite(c, vec4(fragColor / max(v, 0.1), v * smoothstep(0., .1, iIntensity)));\n}\n", 
    "resources/effects/wavy.0.glsl": "// Distort the screen\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2 shift = vec2(0.);\n    shift += cos(M_PI * normCoord) * sin(iTime * vec2(0.1, 0.13));\n    shift += cos(M_PI * normCoord * 2.) * sin(iTime * vec2(0.33, -0.23)) / 2.;\n    shift += cos(M_PI * normCoord * 3.) * sin(iTime * vec2(0.35, -0.53)) / 3.;\n    shift += cos(M_PI * normCoord * 4.) * sin(iTime * vec2(-0.63, -0.20)) / 4.;\n    shift += cos(M_PI * normCoord * 5.) * sin(iTime * vec2(-0.73, 0.44)) / 5.;\n    shift += cos(M_PI * normCoord * 6.) * sin(iTime * vec2(-0.73, 0.74)) / 6.;\n    shift += cos(M_PI * normCoord * 7.) * sin(iTime * vec2(-1.05, -0.52)) / 7.;\n    shift += cos(M_PI * normCoord * 8.) * sin(iTime * vec2(1.45, -1.22)) / 8.;\n\n    shift += sin(M_PI * normCoord * 5.) * sin(iTime * vec2(0.79, -0.47)) / 5.;\n    shift += sin(M_PI * normCoord * 6.) * sin(iTime * vec2(0.33, 0.79)) / 6.;\n    shift += sin(M_PI * normCoord * 7.) * sin(iTime * vec2(1.15, -0.53)) / 7.;\n    shift += sin(M_PI * normCoord * 8.) * sin(iTime * vec2(-1.36, -1.12)) / 8.;\n\n    float amount = 0.1 * iIntensity;\n\n    gl_FragColor = texture2D(iFrame, (normCoord + shift * amount) / aspectCorrection + 0.5);\n}\n", 
    "resources/effects/fly.0.glsl": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Modified for radiance by Eric Van Albert\n\nvoid main()\n{\n    float an = iTime*0.2;\n    vec2 p = mat2(cos(an),-sin(an),sin(an),cos(an)) * (-1. + 2. * uv);\n    vec2 puv = vec2(p.x,1.0)/abs(p.y) + vec2(0., 4.) * iIntensityIntegral;\n    puv = abs(mod(0.2 * puv, 2.) - 1.);\n\n    puv = mix(uv, puv, smoothstep(0.0, 0.2, iIntensity));\n    vec4 c = texture2D(iFrame, puv);\n    //c.a *= abs(uv.y * 0.8);\n    c.a = mix(c.a, c.a * min(abs(p.y)* 3.8, 1.), smoothstep(0.0, 0.2, iIntensity));\n\tgl_FragColor = c;\n}\n", 
    "resources/effects/stripey.0.glsl": "// Vertical stripes with a twinkle effect\n\nvoid main(void) {\n    float xv = round(uv.x * 20. * aspectCorrection.x); \n    gl_FragColor = texture2D(iChannel[0], uv);\n    gl_FragColor.a *= exp(-iIntensity / 20.);\n\n    if (rand(vec2(xv, iTime)) < exp(-iIntensity * 4.)) {\n        gl_FragColor = texture2D(iFrame, uv);\n    }\n}\n", 
    "resources/effects/pink.0.glsl": "// Pink polka dots\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    vec4 c;\n\n    float r = 0.2;\n\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n\n    c = vec4(1., 0.5, 0.5, 1. - smoothstep(r - onePixel, r, length(mod(normCoord * 5. * iIntensity - 0.5, 1.) - 0.5)));\n    c.a *= smoothstep(0., 0.1, iIntensity);\n    gl_FragColor = composite(gl_FragColor, c);\n}\n", 
    "resources/effects/sscan.0.glsl": "// White slit for testing\n\nvoid main(void) {\n    vec2 onePixel = 1. / iResolution;\n    float x = iIntensity;\n    vec4 color = vec4(1.0, 1.0, 1.0, 1. - step(0.5 * onePixel.x, abs(x - uv.x)));\n    gl_FragColor = texture2D(iFrame, uv);\n    gl_FragColor = composite(gl_FragColor, color);\n}\n", 
    "resources/effects/coin.0.glsl": "// Rotate the 'object' in 3D, like a coin\n\n#define WIDTH 0.1\n#define ITERS 64\n\nvec4 lookup(vec2 coord) {\n    return texture2D(iFrame, coord / aspectCorrection + 0.5);\n}\n\nvoid main() {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    vec2  d = vec2(WIDTH, 0.) / ITERS.;\n    vec2  s = normCoord;\n    float phi = iIntensityIntegral * 4;\n    s.x /= sin(phi);\n\n    // This isn't quite right, but it's super easy compared to real geometry\n    d *= abs(cos(phi)) * sign(sin(phi * 2));\n\n    vec4 col = lookup(s);\n    for( int i=0; i<ITERS; i++ )\n    {\n        s += d;\n        vec4 res = lookup(s);\n        col = composite(res, col);\n    }\n\n    gl_FragColor = lookup(normCoord);\n\tgl_FragColor = mix(gl_FragColor, col, smoothstep(0.0, 0.2, iIntensity));\n}\n", 
    "resources/effects/nogreen.0.glsl": "// Zero out the green channel (green is not a creative color)\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    gl_FragColor.g *= 1. - iIntensity;\n}\n", 
    "resources/effects/starfield.1.glsl": "void main(void) {\n    gl_FragColor = texture2D(iChannel[1], (uv - 0.5) * 0.99 + 0.5);\n    gl_FragColor.a *= exp(-1 / 20.);\n    if (rand(vec3(uv, iTime)) < exp((iIntensity - 2.) * 4.))\n        gl_FragColor = vec4(1.);\n}\n", 
    "resources/glsl/crossfader.glsl": "uniform lowp float iParameter;\nvarying highp vec2 coords;\nuniform sampler2D iLeft;\nuniform sampler2D iRight;\n\n// Alpha-compsite two colors, putting one on top of the other\nvec4 composite(vec4 under, vec4 over) {\n    float a_out = 1. - (1. - over.a) * (1. - under.a);\n    return clamp(vec4((over.rgb * over.a  + under.rgb * under.a * (1. - over.a)) / a_out, a_out), vec4(0.), vec4(1.));\n}\n\nvoid main() {\n    vec4 l = texture2D(iLeft, 0.5 * (coords + 1.));\n    vec4 r = texture2D(iRight, 0.5 * (coords + 1.));\n    gl_FragColor = l * (1. - iParameter) + r * iParameter;\n}\n", 
    "resources/effects/purple.0.glsl": "#property description Organic purple waves\n\nvoid main(void) {\n    vec2 normCoord = (uv - 0.5) * aspectCorrection;\n    //mat2 rot = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n    vec4 c;\n\n    normCoord += 0.5;\n    float y = pow(sin(cos(iTime / 4.) * normCoord.y * 8. + normCoord.x), 2.);\n    float x = mod(sin(normCoord.x * 4.) + cos(normCoord.y * normCoord.x * 5.) * (y * 0.2 + 0.8) + 3.0, 1.0);\n\n    c.r = mix(x, y, 0.3);\n    c.b = pow(mix(x, y, 0.7), 0.6);\n    c.g = 0.;\n    c.a = iIntensity;\n\n    //gl_FragColor = composite(texture2D(iInput, uv), c);\n    gl_FragColor = c;\n}\n", 
    "resources/effects/rainbow.0.glsl": "// Cycle the color (in HSV) over time\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n\n    float deviation;\n    deviation = mod(iIntensityIntegral, 1.);\n\n    vec3 hsv = rgb2hsv(gl_FragColor.rgb);\n    hsv.r = mod(hsv.r + 1. + deviation, 1.);\n    gl_FragColor.rgb = mix(gl_FragColor.rgb, hsv2rgb(hsv), smoothstep(0, 0.2, iIntensity));\n}\n", 
    "resources/effects/vignette.0.glsl": "// Applies vignette\n\nfloat hyper_length(vec2 c, float f) {\n    return pow(abs(pow(c.x, f)) + abs(pow(c.y, f)), 1. / f);\n}\n\nvoid main(void) {\n    gl_FragColor = texture2D(iFrame, uv);\n    vec2 coord = (uv - 0.5);\n\n    float f = 3. / iIntensity;\n    float edge1 = 2 * hyper_length(coord, f);\n    float edge2 = 0.5 * length(coord / max(abs(coord.x), abs(coord.y)));\n\n    gl_FragColor.a *= 1. - smoothstep(1. - 0.5 * iIntensity, 1., edge1);\n}\n", 
    "resources/effects/flower.0.glsl": "// Convert vertical lines to radial flower pattern\n\nvoid main(void) {\n    vec2 xy = gl_FragCoord.xy / iResolution;\n    vec2 xy_cent = 2. * xy - 1.;\n    float angle = atan(xy_cent.y, xy_cent.x);\n    float n_sides = (iIntensity * 7.) + 1.;\n    float arc = 2. * M_PI / n_sides;\n    float a1 = mod(angle, arc);\n    float corr = 1. / (pow(cos(a1 - arc / 2.), 2.) * sqrt(2.) * cos(arc / 2.));\n\n    vec2 rtheta = vec2(length(xy_cent) * corr, 0.5 + angle / (2. * M_PI));\n    vec2 uv = mix(xy, rtheta, clamp(iIntensity * 5., 0., 1.));\n\n    gl_FragColor = texture2D(iFrame, uv);\n}\n"
})